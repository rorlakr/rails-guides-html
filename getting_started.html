<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>레일스로 시작하기 — Ruby on Rails Guides</title>
  <link rel="stylesheet" type="text/css" href="stylesheets/style.css" data-turbolinks-track="reload">
  <link rel="stylesheet" type="text/css" href="stylesheets/print.css" media="print">
  <link rel="stylesheet" type="text/css" href="stylesheets/syntaxhighlighter/shCore.css" data-turbolinks-track="reload">
  <link rel="stylesheet" type="text/css" href="stylesheets/syntaxhighlighter/shThemeRailsGuides.css" data-turbolinks-track="reload">
  <link rel="stylesheet" type="text/css" href="stylesheets/fixes.css" data-turbolinks-track="reload">
  <link href="images/favicon.ico" rel="shortcut icon" type="image/x-icon" />
  <script src="javascripts/syntaxhighlighter.js" data-turbolinks-track="reload"></script>
  <script src="javascripts/turbolinks.js" data-turbolinks-track="reload"></script>
  <script src="javascripts/guides.js" data-turbolinks-track="reload"></script>
  <script src="javascripts/responsive-tables.js" data-turbolinks-track="reload"></script>
  <meta property="og:title" content="레일스로 시작하기 — Ruby on Rails Guides" />
  <meta name="description" content="레일스로 시작하기본 가이드 내용에서는 루비온레일스(이하 레일스)를 준비하고 실행하는 것에 대해서 다룬다.본 가이드를 읽은 후에는 다음의 내용을 알게 된다. 레일스를 설치하는 방법, 레일스 애플리케이션을 생성하는 방법, 애플리케이션을 데이터베이스로 연결하는 방법 레일스 애플리케이션의 일반적인 레이아웃 MVC(Model, View, Controller)와 RESTful 디자인에 대한 기본 원리 레일스 애플리케이션의 시작부분을 신속하게 생성하는 방법" />
  <meta property="og:description" content="레일스로 시작하기본 가이드 내용에서는 루비온레일스(이하 레일스)를 준비하고 실행하는 것에 대해서 다룬다.본 가이드를 읽은 후에는 다음의 내용을 알게 된다. 레일스를 설치하는 방법, 레일스 애플리케이션을 생성하는 방법, 애플리케이션을 데이터베이스로 연결하는 방법 레일스 애플리케이션의 일반적인 레이아웃 MVC(Model, View, Controller)와 RESTful 디자인에 대한 기본 원리 레일스 애플리케이션의 시작부분을 신속하게 생성하는 방법" />
  <meta property="og:locale" content="en_US" />
  <meta property="og:site_name" content="Ruby on Rails Guides" />
  <meta property="og:image" content="https://avatars.githubusercontent.com/u/4223" />
  <meta property="og:type" content="website" />
</head>
<body class="guide">
  <div id="topNav">
    <div class="wrapper">
      <strong class="more-info-label">공식 웹사이트 <a href="https://rubyonrails.org/">rubyonrails.org:</a> </strong>
      <span class="red-button more-info-button">
        루비온레일스 웹사이트
      </span>
      <ul class="more-info-links s-hidden">
        <li class="more-info"><a href="https://weblog.rubyonrails.org/">블로그</a></li>
        <li class="more-info"><a href="https://guides.rubyonrails.org/">영문가이드</a></li>
        <li class="more-info"><a href="https://api.rubyonrails.org/">레일스API</a></li>
        <li class="more-info"><a href="https://stackoverflow.com/questions/tagged/ruby-on-rails">질문하기</a></li>
        <li class="more-info"><a href="https://github.com/rails/rails">GitHub에서 기여하기</a></li>
      </ul>
    </div>
  </div>
  <div id="header">
    <div class="wrapper clearfix">
      <h1><a href="index.html" title="Return to home page">Guides.rubyonrails.org</a></h1>
      <ul class="nav">
        <li><a class="nav-item" href="index.html">홈</a></li>
        <li class="guides-index guides-index-large">
          <a href="index.html" id="guidesMenu" class="guides-index-item nav-item">가이드 인덱스</a>
          <div id="guides" class="clearfix" style="display: none;">
            <hr />
            <div class="guides-section-container">
                <div class="guides-section">
                  <dt>시작하면서</dt>
                  <dd><a href="getting_started.html">레일스로 시작하기</a></dd>
                </div>
                <div class="guides-section">
                  <dt>모델</dt>
                  <dd><a href="active_record_basics.html">액티브 레코드 기본</a></dd>
                  <dd><a href="active_record_migrations.html">액티브 레코드 마이그레이션</a></dd>
                  <dd><a href="active_record_validations.html">액티브 레코드 유효성 검증</a></dd>
                  <dd><a href="active_record_callbacks.html">Active Record Callbacks</a></dd>
                  <dd><a href="association_basics.html">Active Record Associations</a></dd>
                  <dd><a href="active_record_querying.html">Active Record Query Interface</a></dd>
                </div>
                <div class="guides-section">
                  <dt>Views</dt>
                  <dd><a href="layouts_and_rendering.html">Layouts and Rendering in Rails</a></dd>
                  <dd><a href="form_helpers.html">Action View Form Helpers</a></dd>
                </div>
                <div class="guides-section">
                  <dt>Controllers</dt>
                  <dd><a href="action_controller_overview.html">Action Controller Overview</a></dd>
                  <dd><a href="routing.html">Rails Routing from the Outside In</a></dd>
                </div>
                <div class="guides-section">
                  <dt>Other Components</dt>
                  <dd><a href="active_support_core_extensions.html">Active Support Core Extensions</a></dd>
                  <dd><a href="action_mailer_basics.html">Action Mailer Basics</a></dd>
                  <dd><a href="active_job_basics.html">Active Job Basics</a></dd>
                  <dd><a href="active_storage_overview.html">Active Storage Overview</a></dd>
                  <dd><a href="action_cable_overview.html">Action Cable Overview</a></dd>
                </div>
                <div class="guides-section">
                  <dt>Digging Deeper</dt>
                  <dd><a href="i18n.html">Rails Internationalization (I18n) API</a></dd>
                  <dd><a href="testing.html">Testing Rails Applications</a></dd>
                  <dd><a href="security.html">Securing Rails Applications</a></dd>
                  <dd><a href="debugging_rails_applications.html">Debugging Rails Applications</a></dd>
                  <dd><a href="configuring.html">Configuring Rails Applications</a></dd>
                  <dd><a href="command_line.html">The Rails Command Line</a></dd>
                  <dd><a href="asset_pipeline.html">The Asset Pipeline</a></dd>
                  <dd><a href="working_with_javascript_in_rails.html">Working with JavaScript in Rails</a></dd>
                  <dd><a href="autoloading_and_reloading_constants.html">Autoloading and Reloading Constants (Zeitwerk Mode)</a></dd>
                  <dd><a href="autoloading_and_reloading_constants_classic_mode.html">Autoloading and Reloading Constants (Classic Mode)</a></dd>
                  <dd><a href="caching_with_rails.html">Caching with Rails: An Overview</a></dd>
                  <dd><a href="api_app.html">Using Rails for API-only Applications</a></dd>
                </div>
                <div class="guides-section">
                  <dt>Extending Rails</dt>
                  <dd><a href="rails_on_rack.html">Rails on Rack</a></dd>
                  <dd><a href="generators.html">Creating and Customizing Rails Generators &amp; Templates</a></dd>
                </div>
                <div class="guides-section">
                  <dt>Contributions</dt>
                  <dd><a href="contributing_to_ruby_on_rails.html">Contributing to Ruby on Rails</a></dd>
                  <dd><a href="api_documentation_guidelines.html">API Documentation Guidelines</a></dd>
                  <dd><a href="ruby_on_rails_guides_guidelines.html">Guides Guidelines</a></dd>
                </div>
                <div class="guides-section">
                  <dt>Policies</dt>
                  <dd><a href="maintenance_policy.html">Maintenance Policy</a></dd>
                </div>
                <div class="guides-section">
                  <dt>Release Notes</dt>
                  <dd><a href="upgrading_ruby_on_rails.html">Upgrading Ruby on Rails</a></dd>
                  <dd><a href="6_0_release_notes.html">Version 6.0 - August 2019</a></dd>
                  <dd><a href="5_2_release_notes.html">Version 5.2 - April 2018</a></dd>
                  <dd><a href="5_1_release_notes.html">Version 5.1 - April 2017</a></dd>
                  <dd><a href="5_0_release_notes.html">Version 5.0 - June 2016</a></dd>
                  <dd><a href="4_2_release_notes.html">Version 4.2 - December 2014</a></dd>
                  <dd><a href="4_1_release_notes.html">Version 4.1 - April 2014</a></dd>
                  <dd><a href="4_0_release_notes.html">Version 4.0 - June 2013</a></dd>
                  <dd><a href="3_2_release_notes.html">Version 3.2 - January 2012</a></dd>
                  <dd><a href="3_1_release_notes.html">Version 3.1 - August 2011</a></dd>
                  <dd><a href="3_0_release_notes.html">Version 3.0 - August 2010</a></dd>
                  <dd><a href="2_3_release_notes.html">Version 2.3 - March 2009</a></dd>
                  <dd><a href="2_2_release_notes.html">Version 2.2 - November 2008</a></dd>
                </div>
            </div>
          </div>
        </li>
        <li><a class="nav-item" href="contributing_to_ruby_on_rails.html">기여하기</a></li>
        <li class="guides-index guides-index-small">
          <select class="guides-index-item nav-item">
            <option value="index.html">가이드 인덱스</option>
              <optgroup label="시작하면서">
                  <option value="getting_started.html">레일스로 시작하기</option>
              </optgroup>
              <optgroup label="모델">
                  <option value="active_record_basics.html">액티브 레코드 기본</option>
                  <option value="active_record_migrations.html">액티브 레코드 마이그레이션</option>
                  <option value="active_record_validations.html">액티브 레코드 유효성 검증</option>
                  <option value="active_record_callbacks.html">Active Record Callbacks</option>
                  <option value="association_basics.html">Active Record Associations</option>
                  <option value="active_record_querying.html">Active Record Query Interface</option>
              </optgroup>
              <optgroup label="Views">
                  <option value="layouts_and_rendering.html">Layouts and Rendering in Rails</option>
                  <option value="form_helpers.html">Action View Form Helpers</option>
              </optgroup>
              <optgroup label="Controllers">
                  <option value="action_controller_overview.html">Action Controller Overview</option>
                  <option value="routing.html">Rails Routing from the Outside In</option>
              </optgroup>
              <optgroup label="Other Components">
                  <option value="active_support_core_extensions.html">Active Support Core Extensions</option>
                  <option value="action_mailer_basics.html">Action Mailer Basics</option>
                  <option value="active_job_basics.html">Active Job Basics</option>
                  <option value="active_storage_overview.html">Active Storage Overview</option>
                  <option value="action_cable_overview.html">Action Cable Overview</option>
              </optgroup>
              <optgroup label="Digging Deeper">
                  <option value="i18n.html">Rails Internationalization (I18n) API</option>
                  <option value="testing.html">Testing Rails Applications</option>
                  <option value="security.html">Securing Rails Applications</option>
                  <option value="debugging_rails_applications.html">Debugging Rails Applications</option>
                  <option value="configuring.html">Configuring Rails Applications</option>
                  <option value="command_line.html">The Rails Command Line</option>
                  <option value="asset_pipeline.html">The Asset Pipeline</option>
                  <option value="working_with_javascript_in_rails.html">Working with JavaScript in Rails</option>
                  <option value="autoloading_and_reloading_constants.html">Autoloading and Reloading Constants (Zeitwerk Mode)</option>
                  <option value="autoloading_and_reloading_constants_classic_mode.html">Autoloading and Reloading Constants (Classic Mode)</option>
                  <option value="caching_with_rails.html">Caching with Rails: An Overview</option>
                  <option value="api_app.html">Using Rails for API-only Applications</option>
              </optgroup>
              <optgroup label="Extending Rails">
                  <option value="rails_on_rack.html">Rails on Rack</option>
                  <option value="generators.html">Creating and Customizing Rails Generators &amp; Templates</option>
              </optgroup>
              <optgroup label="Contributions">
                  <option value="contributing_to_ruby_on_rails.html">Contributing to Ruby on Rails</option>
                  <option value="api_documentation_guidelines.html">API Documentation Guidelines</option>
                  <option value="ruby_on_rails_guides_guidelines.html">Guides Guidelines</option>
              </optgroup>
              <optgroup label="Policies">
                  <option value="maintenance_policy.html">Maintenance Policy</option>
              </optgroup>
              <optgroup label="Release Notes">
                  <option value="upgrading_ruby_on_rails.html">Upgrading Ruby on Rails</option>
                  <option value="6_0_release_notes.html">Version 6.0 - August 2019</option>
                  <option value="5_2_release_notes.html">Version 5.2 - April 2018</option>
                  <option value="5_1_release_notes.html">Version 5.1 - April 2017</option>
                  <option value="5_0_release_notes.html">Version 5.0 - June 2016</option>
                  <option value="4_2_release_notes.html">Version 4.2 - December 2014</option>
                  <option value="4_1_release_notes.html">Version 4.1 - April 2014</option>
                  <option value="4_0_release_notes.html">Version 4.0 - June 2013</option>
                  <option value="3_2_release_notes.html">Version 3.2 - January 2012</option>
                  <option value="3_1_release_notes.html">Version 3.1 - August 2011</option>
                  <option value="3_0_release_notes.html">Version 3.0 - August 2010</option>
                  <option value="2_3_release_notes.html">Version 2.3 - March 2009</option>
                  <option value="2_2_release_notes.html">Version 2.2 - November 2008</option>
              </optgroup>
          </select>
        </li>
      </ul>
    </div>
  </div>
  <hr class="hide" />

  <div id="feature">
    <div class="wrapper">
      <h2 id="getting-started-with-rails">레일스로 시작하기</h2><p>본 가이드 내용에서는 루비온레일스(이하 레일스)를 준비하고 실행하는 것에 대해서 다룬다.</p><p>본 가이드를 읽은 후에는 다음의 내용을 알게 된다.</p>
<ul>
<li>레일스를 설치하는 방법, 레일스 애플리케이션을 생성하는 방법, 애플리케이션을 데이터베이스로 연결하는 방법</li>
<li>레일스 애플리케이션의 일반적인 레이아웃</li>
<li>MVC(Model, View, Controller)와 RESTful 디자인에 대한 기본 원리</li>
<li>레일스 애플리케이션의 시작부분을 신속하게 생성하는 방법</li>
</ul>


              <div id="subCol">
          <h3 class="chapter"><img src="images/chapters_icon.gif" alt="" />Chapters</h3>
          <ol class="chapters">
<li><a href="#guide-assumptions">가이드에 대한 전제조건</a></li>
<li><a href="#what-is-rails">레일스란 무엇인가</a></li>
<li>
<a href="#creating-a-new-rails-project">레일스 프로젝트 생성하기</a>

<ul>
<li><a href="#installing-rails">레일스 설치하기</a></li>
<li><a href="#creating-the-blog-application">Blog 애플리케이션 생성하기</a></li>
</ul>
</li>
<li>
<a href="#hello-rails-bang">Hello, Rails!</a>

<ul>
<li><a href="#starting-up-the-web-server">웹서버 시작하기</a></li>
<li><a href="#say-hello-rails">"Hello, Rails" 표시하기</a></li>
<li><a href="#setting-the-application-home-page">애플리케이션 홈 페이지 설정하기</a></li>
</ul>
</li>
<li>
<a href="#getting-up-and-running">작동하기</a>

<ul>
<li><a href="#laying-down-the-groundwork">기본틀 잡기</a></li>
<li><a href="#the-first-form">첫번째 폼</a></li>
<li><a href="#creating-articles">기사 작성하기</a></li>
<li><a href="#creating-the-article-model">Article 모델 생성하기</a></li>
<li><a href="#running-a-migration">마이그레이션 작업 수행하기</a></li>
<li><a href="#saving-data-in-the-controller">컨트롤러에서 데이터 저장하기</a></li>
<li><a href="#showing-articles">기사 보여주기</a></li>
<li><a href="#listing-all-articles">모든 기사 목록 보기</a></li>
<li><a href="#adding-links">링크 추가하기</a></li>
<li><a href="#adding-some-validation">몇가지 유효성 검사 추가하기</a></li>
<li><a href="#updating-articles">기사 업데이트하기</a></li>
<li><a href="#using-partials-to-clean-up-duplication-in-views">파셜을 이용하여 뷰의 중복 코드 정리하기</a></li>
<li><a href="#deleting-articles">기사 삭제하기</a></li>
</ul>
</li>
<li>
<a href="#adding-a-second-model">두번째 모델 추가하기</a>

<ul>
<li><a href="#generating-a-model">모델 생성하기</a></li>
<li><a href="#associating-models">모델 관계 선언하기</a></li>
<li><a href="#adding-a-route-for-comments">댓글에 대한 라우트 추가하기</a></li>
<li><a href="#generating-a-controller">컨트롤러 생성하기</a></li>
</ul>
</li>
<li>
<a href="#refactoring">리팩토링하기</a>

<ul>
<li><a href="#rendering-partial-collections">파셜 컬렉션 렌더링하기</a></li>
<li><a href="#rendering-a-partial-form">파셜 폼 렌더링하기</a></li>
</ul>
</li>
<li>
<a href="#deleting-comments">댓글 삭제하기</a>

<ul>
<li><a href="#deleting-associated-objects">관련 객체 삭제하기</a></li>
</ul>
</li>
<li>
<a href="#security">보안</a>

<ul>
<li><a href="#basic-authentication">기본 인증</a></li>
<li><a href="#other-security-considerations">다른 보안 고려사항</a></li>
</ul>
</li>
<li><a href="#whats-next">향후 계획</a></li>
<li><a href="#configuration-gotchas">설정시 유의사항</a></li>
</ol>

        </div>

    </div>
  </div>

  <div id="container">
    <div class="wrapper">
      <div id="mainCol">
        <h3 id="guide-assumptions"><a class="anchorlink" href="#guide-assumptions">1 가이드에 대한 전제조건</a></h3><p>본 가이드 내용은 레일스 애플리케이션을 만들어 본 경험이 없는 초보자를 대상으로 작성되었다. 반드시 레일스에 대한 경험을 필요로 하지 않는다.</p><p>레일스는 루비 언어로 만들어진 웹애플리케이션 프레임워크이다. 
루비 언어에 대한 사전 지식이 없이 바로 레일스로 작업을 하게 되면 매우 경사진 학습곡선을 경험하게 될 것이다. 아래에 루비 언어를 배우기 위한 온라인 자원에 대한 몇가지 목록을 모아 놓았다.</p>
<ul>
<li><a href="https://www.ruby-lang.org/en/documentation/">루비언어 공식 웹사이트</a></li>
<li><a href="https://github.com/EbookFoundation/free-programming-books/blob/master/free-programming-books.md#ruby">무료 프로그래밍 서적 목록</a></li>
</ul>
<p>주의할 것은 위에서 소개한 서적 중에는, 그 내용이 아주 훌륭한 것이지만, 오래된 버전인 루비 1.6과 주로 1.8 버전에 대한 것들이 있어서 레일스로 개발할 때 주로 접하게 되는 루비 문법들이 포함되지 않을 수 있다는 것이다.</p><h3 id="what-is-rails"><a class="anchorlink" href="#what-is-rails">2 레일스란 무엇인가</a></h3><p>레일스란 루비 언어로 작성된 웹애플리케이션 개발 프레임워크이다.
모든 개발자들이 작업을 시작할 때 필요로 하는 것들이 사전에 준비된 것으로 가정하여 웹애플리케이션을 보다 쉽게 개발할 수 있도록 만들어졌다.
다수의 언어와 프레임워크보다 더 작은 량의 코드를 작성하여 더 많은 것을 구현할 수 있게 해준다.
고급 레일스 개발자들 역시 레일스가 웹애플리케이션 개발을 더 재밋게 해 준다고 말한다.</p><p>레일스는 독단적인 측면을 가지는 소프트웨어다. 즉 최선의 방식이 있다고 가정하여 그 방법을 사용하도록 권하지만 경우에 따라서는 다른 대안을 사용하지 않도록 한다. 소위 "레일스 방식"을 배우게 되면 생산성에 있어서 어마어마한 향상을 가져오게 되는 것을 알게 될 것이다. 다른 언어를 사용할 때 익혔던 습관을 레일스 개발시에 버리지 못하거나 다른 곳에서 배웠던 패턴을 그대로 사용하려고 할 경우는 레일스를 사용하므로써 얻게 되는 즐거움을 덜 느끼게 될 것이다.</p><p>레일스 철학은 두 개의 중요한 가이드 원칙을 포함한다.</p>
<ul>
<li>
<strong>Don't Repeat Yourself(같은 내용의 정보를 반복하지 말 것):</strong> DRY란 하나의 소프트웨어 개발 원칙으로 "모든 지식은 하나의 시스템 내에서 유일해야 하고 모호성이 없어야 하며 권위를 가져야 한다"는 내용을 의미한다. 같은 내용의 정보를 반복해서 작성하지 않으므로써 코드를 더 잘 유지할 수 있고 더 많은 확장성을 부여할 수 있으며 버그를 줄일 수 있게 되는 것이다.</li>
<li>
<strong>Convention Over Configuration(설정보다는 관례를 우선시 함):</strong> 레일스는 웹애플리케이션에서 발생할 수 있는 다양한 작업들에 대한 최선의 방법을 알고 있기 때문에, 한없이 이어지는 설정파일들을 사용해서 상세한 설정 내용을 명시하는 대신에 이런 것들에 대한 일련의 사전 정의된 설정을 기본 규칙으로 지정해 준다.</li>
</ul>
<h3 id="creating-a-new-rails-project"><a class="anchorlink" href="#creating-a-new-rails-project">3 레일스 프로젝트 생성하기</a></h3><p>본 가이드를 읽어가는 최선의 방식은 단계별로 따라서 해 보는 것이다. 모든 단계는 예제 애플리케이션을 실행하는데 필수이며 어떠한 코드나 단계도 추가적으로 필요하지 않다.  </p><p>본 가이드를 따라하면 <code>blog</code>라는 간단한 웹브로그 프로젝트를 만들게 될 것이다. 프로젝트를 진행하기 전에 각자의 시스템에 레일스가 설치되어 있어야 한다.</p><div class="info"><p>아래의 예제에서 사용하는 <code>$</code> 문자는 유닉스계열의 운영체제에서 터미널 프롬프트로 사용하는 것인데 설정에 따라 다르게 보일 수 있다. 윈도우를 사용할 경우에는 <code>C:\sourc_code</code>와 같이 보일 것이다.</p></div><h4 id="installing-rails"><a class="anchorlink" href="#installing-rails">3.1 레일스 설치하기</a></h4><p>레일스를 설치하기 전에 각자의 시스템에 레일스 프레이워크에서 사용하는 연관 언어나 프로그램이 설치되어 있는지 확인해야 하는데, 여기에는 루비와 SQLite3 등이 포함된다.</p><p>우선 터미널 프로그램을 실행한 후 커맨드라인 프롬프트를 연다. macOS에서는 Terminal.app 프로그램을 실행하고, 윈도에서는 시작 메뉴로부터 "실행(Run)" 명령을 선택한 후 'cmd.exe'라고 입력하여 엔터키를 입력한다. 달러 표시 <code>$</code> 문자 뒤에 오는 명령은 커맨드라인에서 실행해야 한다. 이어서 이설치된 루비 버전을 확인한다.</p><div class="code_container">
<pre class="brush: plain; gutter: false; toolbar: false">
$ ruby -v
ruby 2.5.0

</pre>
</div>
<p>레일스는 루비 버전이 최소한 2.5.0 이상이어야 한다. 따라서, 이전 버전으로 확인될 경우는 최신버전으로 설치할 필요가 있다.</p><div class="info"><p>윈도우 시스템에 레일스를 신속하게 설치하기 위해서는 <a href="http://railsinstaller.org">Rails Installer</a>를 사용할 수 있다. 대부분의 운영체제에서 더 많은 설치 방법을 찾아 보길 원한다면 <a href="https://www.ruby-lang.org/en/documentation/installation/">ruby-lang.org</a>를 살펴보기 바란다.</p></div><p>윈도우에서 작업을 할 경우는, <a href="https://rubyinstaller.org/downloads/">Ruby Installer Development Kit</a>를 추가로 설치해야 한다.</p><p>또한 SQLite3 데이터베이스를 설치할 필요가 있다.
많은 사람들이 사용하는 다수의 유닉스계열의 운영체제는 SQLite3 가용 버전이 미리 설치되어 있다. 
윈도우에서는 Rails Installer를 이용하여 설치한 경우, 이미 SQLite가 설치되어 있다. 기타 다른 경우에는 <a href="https://www.sqlite.org">SQLite3 웹사이트</a>를 방문하여 설치 안내문을 참고할 수 있다.
제대로 설치되었을 경우 PATH에 경로가 추가되었는지 확인해 보기 바란다.</p><div class="code_container">
<pre class="brush: plain; gutter: false; toolbar: false">
$ sqlite3 --version

</pre>
</div>
<p>위의 명령을 실행할 경우 버전이 표시되어야 한다.</p><p>레일스를 설치하기 위해서는 RubyGems에서 제공하는 <code>gem install</code> 명령을 실행한다.</p><div class="code_container">
<pre class="brush: plain; gutter: false; toolbar: false">
$ gem install rails

</pre>
</div>
<p>이상의 모든 것이 제대로 설치되었다는 것을 확인하기 위해서 아래의 명령을 실행할 수 있어야 한다.</p><div class="code_container">
<pre class="brush: plain; gutter: false; toolbar: false">
$ rails --version

</pre>
</div>
<p>"Rails 6.0.0"과 같이 표시된다면 이제 시작할 준비가 된 것이다.</p><h4 id="creating-the-blog-application"><a class="anchorlink" href="#creating-the-blog-application">3.2 Blog 애플리케이션 생성하기</a></h4><p>레일스에서 기본으로 제공되는 많은 생성자 스크립트를 이용하면 특정 작업에 필요한 모든 것을 자동으로 생성해 주기 때문에 개발을 보다 쉽게 할 수 있다. 이 중에 하나는 애플리케이션을 만들어 주는 생성자 스크립트인데 레일스 애플리케이션의 기본 골격구조를 제공해 주기 때문에 직접 코드를 작성할 필요가 없다. Creating the blog application</p><p>이 생성자를 사용하기 위해서는 터미널을 열고 파일을 생성할 권한이 있는 적당한 디렉토리로 이동한 후 아래와 같이 입력한다.</p><div class="code_container">
<pre class="brush: plain; gutter: false; toolbar: false">
$ rails new blog

</pre>
</div>
<p>이로써 <code>blog</code> 디렉토리에 Blog라는 레일스 애플리케이션이 생성되고 <code>bundle install</code> 명령으로 <code>Gemfile</code>에 명시된 젬들이 설치될 것이다.</p><div class="note"><p>Windows Subsystem for Linux(WSL)를 사용할 경우에는 현재 파일 시스템 알림 기능상에 제약점이 발견되어 <code>rails new blog --skip-spring --skin-listen</code> 와 같이 옵션을 추가하여 명령을 실행하여 <code>spring</code>과 <code>listen</code> 젬의 기능을 중단해야 한다.</p></div><div class="info"><p><code>rails new -h</code> 명령을 실행하면 레일스 애플리케이션 빌더가 사용할 수 있는 모든 커맨드라인 옵션들을 볼 수 있다.</p></div><p>blog 애플리케이션을 생성한 후에는 해당 폴더로 이동한다.</p><div class="code_container">
<pre class="brush: plain; gutter: false; toolbar: false">
$ cd blog

</pre>
</div>
<p><code>blog</code> 디렉토리에는 다수의 자동생성된 파일과 폴더가 존재하는데 레일스 애플리케이션의 구조를 반영한 것이다. 본 튜토리얼상의 대부분의 작업은 <code>app</code> 폴더에서 진행할 것이지만 레일스에서 디폴트로 생성한 파일과 폴더의 기능들에 대한 기본 설명을 아래에 기술해 놓았다.</p>
<table>
<thead>
<tr>
<th>파일/폴더</th>
<th>용도</th>
</tr>
</thead>
<tbody>
<tr>
<td>app/</td>
<td>애플리케이션의 컨트롤러, 모델, 뷰, 헬퍼, 메일러, 채널, 작업 및 애셋을 포함한다. 본 가이드의 나머지 부분에서는 이 폴더에 중점을 둘 것이다.</td>
</tr>
<tr>
<td>bin/</td>
<td>앱을 시작하는 레일스 스크립트를 포함하며 애플리케이션 설정, 업데이트, 배포 또는 실행하는 데 사용하는 스크립트를 포함 할 수 있다.</td>
</tr>
<tr>
<td>config/</td>
<td>애플리케이션의 라우트, 데이터베이스 등을 구성한다. <a href="configuring.html">Configuring Rails Applications</a>에 자세히 설명되어 있다.</td>
</tr>
<tr>
<td>config.ru</td>
<td>애플리케이션을 시작하는 데 사용되는 랙(Rack) 기반 서버의 랙 구성. 랙에 대한 자세한 내용은 <a href="https://rack.github.io/">Rack 웹 사이트</a>를 참조한다.</td>
</tr>
<tr>
<td>db/</td>
<td>현재 데이터베이스 스키마와 데이터베이스 마이그레이션이 포함되어 있다.</td>
</tr>
<tr>
<td>Gemfile<br>Gemfile.lock</td>
<td>이 파일을 사용하면 레일스 애플리케이션에 필요한 젬(gem) 의존성을 지정할 수 있다. 이 파일은 Bundler 젬에서 사용한다. Bundler에 대한 자세한 내용은 <a href="https://bundler.io">Bundler 웹 사이트</a>를 참조한다.</td>
</tr>
<tr>
<td>lib/</td>
<td>애플리케이션을 위한 확장 모듈.</td>
</tr>
<tr>
<td>log/</td>
<td>애플리케이션 로그 파일</td>
</tr>
<tr>
<td>package.json</td>
<td>이 파일을 사용하면 레일스 애플리케이션에 필요한 npm 종속성을 지정할 수 있다. 이 파일은 Yarn에서 사용한다. Yarn에 대한 자세한 내용은 <a href="https://yarnpkg.com/lang/en/">Yarn 웹 사이트</a>를 참조한다.</td>
</tr>
<tr>
<td>public/</td>
<td>누구라도 접급할 수 있는 유일한 폴더이다. 정적 파일 및 컴파일 된 애셋을 포함한다.</td>
</tr>
<tr>
<td>Rakefile</td>
<td>이 파일은 커맨드 라인에서 실행할 수 있는 태스크(task)를 찾아서 로드한다. 태스크 정의는 레일스의 구성 요소 전체에 걸쳐 정의된다. <code>Rakefile</code>을 변경하는 대신 애플리케이션의 <code>lib/tasks</code> 디렉토리에 파일을 추가한 후 자신의 태스크를 추가해야 한다.</td>
</tr>
<tr>
<td>README.md</td>
<td>애플리케이션에 대한 간단한 사용 설명서이다. 이 파일을 편집하여 다른 사용자에게 애플리케이션의 기능, 설정 방법 등을 알려 주어야 한다.</td>
</tr>
<tr>
<td>storage/</td>
<td>디스크 서비스용 액티브 스토리지 파일. 이에 대해서는 <a href="active_storage_overview.html">Active Storage Overview</a>에서 다룬다.</td>
</tr>
<tr>
<td>test/</td>
<td>유닛 테스트, 픽스쳐(fixtures, 테스트 데이터) 및 기타 테스트 장치. 이것들은 <a href="testing.html">Testing Rails Applications</a>에서 다룬다.</td>
</tr>
<tr>
<td>tmp/</td>
<td>임시 파일 (캐시(cache)와 pid 파일).</td>
</tr>
<tr>
<td>vendor/</td>
<td>모든 벤더(타사) 코드를 위한 장소이다. 전형적인 레일스 애플리케이션에서는 벤더에서 제공하는 젬을 여기에 포함한다.</td>
</tr>
<tr>
<td>.gitignore</td>
<td>이 파일은 git에게 무시해야 할 파일 (또는 패턴)을 알려준다. 파일 무시에 대한 자세한 내용은 <a href="https://help.github.com/articles/ignoring-files">GitHub - Ignoring files</a>를 참조한다.</td>
</tr>
<tr>
<td>.ruby-version</td>
<td>이 파일에는 기본 루비 버전이 포함되어 있다.</td>
</tr>
</tbody>
</table>
<h3 id="hello-rails-bang"><a class="anchorlink" href="#hello-rails-bang">4 Hello, Rails!</a></h3><p>먼저, 스크린 상에 어떤 문자들이 보이도록 해 보자. 이를 위해서 레일스 애플리케이션 서버를 실행시켜야 한다.</p><h4 id="starting-up-the-web-server"><a class="anchorlink" href="#starting-up-the-web-server">4.1 웹서버 시작하기</a></h4><p>레일스 애플리케이션은 사실 이미 정상적으로 동작이 가능한 상태이다. 이를 확인하려면 각자의 개발 머신에서 웹서버를 시작할 필요가 있다. <code>blog</code> 디렉토리에서 아래의 명령을 실행하여 서버를 시작할 수 있다.</p><div class="code_container">
<pre class="brush: plain; gutter: false; toolbar: false">
$ rails server

</pre>
</div>
<div class="info"><p>윈도우를 사용할 경우에는 <code>bin</code> 폴더에 있는 스크립트를, 예: <code>ruby bin\rails server</code>, 루비 인터프리터로 직접 넘겨 주어야 한다.</p></div><div class="info"><p>자바스크립트 애셋을 압축하기 위해서는 시스템에 자바스크립트 런타임이 설치되어 있어야 하는데, 만약 그렇지 못할 경우에는 <code>execjs</code> 에러가 발생할 것이다. 대부분의 경우 macOS와 윈도우에는 자바스크립트 런타임이 이미 설치되어 있다. <code>therubyrhino</code>는 JRuby 사용자들을 위한 권장되는 런타임이며 JRuby 하에 생성된 앱의 <code>Gemfile</code>에 기본으로 추가된다. <a href="https://github.com/rails/execjs#readme">ExecJS</a>에서 모든 사용가능한 런타임을 찾아 볼 수 있다.</p></div><p>이로써 레일스에서 디폴트로 배포하는 웹서버인 Puma를 시동하게 될 것이다. 작업 중인 애플리케이션이 동작하는 것을 확인하기 위해서 브라우저를 연 후 <a href="http://localhost:3000">http://localhost:3000</a>로 이동했을 때 아래와 같은 레일스 디폴트 정보 페이지를 볼 수 있어야 한다.</p><p><img src="images/getting_started/rails_welcome.png" alt="Welcome aboard screenshot"></p><div class="info"><p>웹서버를 중단하기 위해서는 서버가 실행 중인 터미널 윈도우에서 Ctrl+C를 누른다. 서버가 중단된 것을 확인하기 위해서는 커맨드 프롬프트를 다시 볼 수 있어야 한다. macOS를 포함해서 대부분의 유닉스계열의 시스템에서는 커맨드 프롬프트가 달러 문자 <code>$</code>로 표시될 것이다. 개발 모드에서는 변경된 내용이 서버에 자동으로 반영되기 때문에 일반적으로 서버를 재시동할 필요가 없다.</p></div><p>"Welcome aboard" 페이지는 레일스 애플리케이션이 제대로 생성되었는지를 알 수 있는 일종의 <em>smoke test</em> 의 의미를 가진다. 즉, 소프트웨어가 제대로 설정되어 페이지를 서비스할 수 있음을 확인하는 것이다.</p><h4 id="say-hello-rails"><a class="anchorlink" href="#say-hello-rails">4.2 "Hello, Rails" 표시하기</a></h4><p>"Hello" 문자를 표시하기 위해서는 최소한 하나의 <em>controller(컨트롤러)</em> 와 하나의 <em>view(뷰)</em> 를 생성해야 한다.</p><p>컨트롤러는 애플리케이션에 대한 특정 요청를 받는 역할을 한다.
<em>Routing(라우팅)</em> 은 어떤 컨트롤러가 어떤 요청을 받을 것인가를 결정한다. 종종 하나의 컨트롤러가 하나 이상의 라우트로 연결되기도 하는데 이 때 특정 컨트롤러의 라우트들은 각기 다른 <em>actions(액션)</em> 을 호출하여 서비스한다. 액션은 정보를 모아서 뷰에 제공하는 역할을 수행한다.</p><p>뷰는 이러한 정보를 사람이 읽을 수 있는 형태로 표시하는데 중요한 차이점은 정보를 수집하는 곳이 뷰가 아니고 <em>컨트롤러</em> 라는 점이다. 뷰는 바로 이러한 정보를 단지 표시만해야 한다. 보통 뷰 템플릿은 eRuby(Embeded Ruby)로 작성하는데 사용자들에게 보내지기 전에 레일스 엔진이 요청 주기에 따라 처리하게 된다.</p><p>컨트롤러를 새로이 추가할 때는 "controlller" 생성자를 실행해야 하는데 이 때 "Welcome"이라는 컨트롤러와 "index"라는 액션을 아래와 같이 알려 주어야 한다.</p><div class="code_container">
<pre class="brush: plain; gutter: false; toolbar: false">
$ rails generate controller Welcome index

</pre>
</div>
<p>이로써 다수의 파일과 하나의 라우트가 생성될 것이다.</p><div class="code_container">
<pre class="brush: plain; gutter: false; toolbar: false">
create  app/controllers/welcome_controller.rb
 route  get 'welcome/index'
invoke  erb
create    app/views/welcome
create    app/views/welcome/index.html.erb
invoke  test_unit
create    test/controllers/welcome_controller_test.rb
invoke  helper
create    app/helpers/welcome_helper.rb
invoke    test_unit
invoke  assets
invoke    scss
create      app/assets/stylesheets/welcome.scss

</pre>
</div>
<p>이 중에서 가장 중요한 것은 <code>app/controllers/welcome_controller.rb</code>에 위치한 컨트롤러 파일과 <code>app/views/welcome/index.html.erb</code>에 위치한 뷰 파일이다.</p><p>텍스트 에디터 상에서 <code>app/views/welcome/index.html.erb</code> 파일을 열고 기존 코드를 모두 삭제한 후 아래의 코드로 대체한다.</p><div class="code_container">
<pre class="brush: xml; gutter: false; toolbar: false">
&lt;h1&gt;Hello, Rails!&lt;/h1&gt;

</pre>
</div>
<h4 id="setting-the-application-home-page"><a class="anchorlink" href="#setting-the-application-home-page">4.3 애플리케이션 홈 페이지 설정하기</a></h4><p>컨트롤러와 뷰를 작성했기 때문에 이제 레일스에게 "Hello, Rails!"라는 글을 보여줄 시점을 알려 주어야 한다. 여기서는 루트 URL <a href="http://localhost:3000">http://localhost:3000</a>로 이동할 때 보여 주고자 한다. 이 순간 바로 "Welcom aboard" 라는 글을 보게 될 것이다.</p><p>다음으로는 실제 홈 페이지의 위치를 지정해 주어야 한다.</p><p>에디터 상에서 <code>config/routes.rb</code> 파일을 열면 아래와 같은 내용이 보인다.</p><div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
Rails.application.routes.draw do
  get 'welcome/index'

  # For details on the DSL available within this file, see https://guides.rubyonrails.org/routing.html
end

</pre>
</div>
<p>이것은 특별한 <a href="https://en.wikipedia.org/wiki/Domain-specific_language">DSL (domain-specific language)</a>로 작성된 라우트 항목들을 포함하는 애플리케이션의 <em>routing file(라우팅 파일)</em> 이며 이 파일을 통해서 레일스는 서버로 들어오는 요청을 어떤 컨트롤러와 액션으로 연결할지 알게 된다. 이 파일에 <code>root 'welcome#index'</code> 코드라인을 추가하면 아래와 같이 보이게 된다.</p><div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
Rails.application.routes.draw do
  get 'welcome/index'

  root 'welcome#index'
end

</pre>
</div>
<p><code>root 'welcome#index'</code>는 레일스에게 애플리케이션 루트로 들어오는 요청을 welcome 컨트롤러의 index 액션으로 매핑하도록 알려 주며 <code>get 'welcome/index'</code>는 <a href="http://localhost:3000/welcome/index">http://localhost:3000/welcome/index</a>로 들어오는 요청을 welcome 컨트롤러의 index 액션으로 매핑하도록 알려 준다. 이것은 이전에 컨트롤러 생성자(<code>rails generate controller Welcome index</code>)를 실행했을 때 이미 만들어졌던 것이다.</p><p>컨트롤러를 만들기 위해서 중단한 경우에는 웹서버를 시작한 후 브라우저 상에서 <a href="http://localhost:3000">http://localhost:3000</a>로 이동한다. 이 때 <code>app/views/welcome/index.html.erb</code> 파일에 추가했던 "Hello, Rails!" 메시지를 보게 된다면 새로 추가한 라우트가 <code>WelcomeController</code>의 <code>index</code> 액션으로 제대로 이동하여 뷰를 정확하게 렌더링하고 있다는 것을 간접적으로 시사하는 것이다.</p><div class="info"><p>라우팅에 대한 더 자세한 내용은 <a href="routing.html">Rails Routing from the Outside In</a>를 참고하기 바란다.</p></div><h3 id="getting-up-and-running"><a class="anchorlink" href="#getting-up-and-running">5 작동하기</a></h3><p>컨트롤러, 액션, 뷰 작성법을 알게 되었으니 이제 좀 더 실질적인 것을 만들어 보도록 하자.</p><p>Blog 애플리케이션에서 새로운 <em>resource(리소스)</em> 를 하나 추가할 것이다. 리소스란 기사(읽은거리), 사람, 동물 등과 같이 비슷한 객체들을 일컫는 말한다. 특정 리소스에 대한 항목을 생성하고, 읽고, 업데이트하고, 삭제할 수 있고 이러한 작업을 <em>CRUD</em> 작업으로 말하기도 한다.</p><p>레일스에서 제공하는 <code>resources</code> 메소드는 표준 REST 리소스를 선언하는데 사용할 수 있다. 따라서 <code>config/routes.rb</code> 파일에 <em>article resource</em> 를 추가할 필요가 있으며 그 파일 내용은 아래와 같다.</p><div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
Rails.application.routes.draw do
  get 'welcome/index'

  resources :articles

  root 'welcome#index'
end

</pre>
</div>
<p><code>rails routes</code> 명령을 실행하면 모든 표준 RESTful 액션에 대한 라우트 정의를 볼 수 있을 것이다. prefix 열과 다른 열의 의미는 나중에 보게 될 것이지만 지금 당장은 레일스가 단수형 <code>article</code>을 추론한 후 각 라우트를 구분하기 위해 의미있게 사용하는 것을 주목한다.</p><div class="code_container">
<pre class="brush: plain; gutter: false; toolbar: false">
$ rails routes
       Prefix Verb   URI Pattern                  Controller#Action
welcome_index GET    /welcome/index(.:format)     welcome#index
     articles GET    /articles(.:format)          articles#index
              POST   /articles(.:format)          articles#create
  new_article GET    /articles/new(.:format)      articles#new
 edit_article GET    /articles/:id/edit(.:format) articles#edit
      article GET    /articles/:id(.:format)      articles#show
              PATCH  /articles/:id(.:format)      articles#update
              PUT    /articles/:id(.:format)      articles#update
              DELETE /articles/:id(.:format)      articles#destroy
         root GET    /                            welcome#index

</pre>
</div>
<p>다음 섹션에서 새 기사를 생성한 후 결과를 볼 수 있도록 기능을 추가할 것이다. 이것은 CRUD에서 "C"와 "R"에 해당하는 것으로 create(생성하기)와 read(읽기)를 의미한다. 이러한 작업을 하는 폼 형태는 아래와 같이 보일 것이다.</p><p><img src="images/getting_started/new_article.png" alt="The new article form"></p><p>현재 상태는 기본 형태로 보이지만 작동하는데 문제가 없다. 이후에 스타일을 좋게 만드는 작업을 보게 될 것이다.</p><h4 id="laying-down-the-groundwork"><a class="anchorlink" href="#laying-down-the-groundwork">5.1 기본틀 잡기</a></h4><p>먼저, 새로운 기사를 작성할 장소가 필요하다. 이를 위한 적당한 위치는 <code>/articles/new</code>가 될 것이다. 이미 정의된 바 있는 라우트를 따라 외부로부터의 요청은 <code>/articles/new</code>로 이어질 것이다. <a href="http://localhost:3000/articles/new">http://localhost:3000/articles/new</a>로 이동하면 라우팅 에러가 발생할 것이다. </p><p><img src="images/getting_started/routing_error_no_controller.png" alt="Another routing error, uninitialized constant ArticlesController"></p><p>이 에러는 해당 라우트의 요청을 처리하기 위해서는 하나의 컨트롤러가 정의되어 있어야 하기 때문에 발생한다.
이러한 문제를 해결하는 방법은 간단하다. <code>ArticlesController</code>라는 컨트롤러를 생성하는 것이다. 아래와 같은 명령을 실행하면 이러한 작업을 수행할 수 있다.</p><div class="code_container">
<pre class="brush: plain; gutter: false; toolbar: false">
$ rails generate controller Articles

</pre>
</div>
<p>방금 생성된 <code>app/controllers/articles_controller.rb</code> 파일을 열면 빈 컨트롤러를 보게 될 것이다.</p><div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
class ArticlesController &lt; ApplicationController
end

</pre>
</div>
<p>이 컨트롤러는 <code>ApplicationController</code>로부터 상속받는 단지 하나의 클래스에 불과하다.
이 클래스 내에 컨트롤러 액션으로 동작하는 메소드를 정의하게 된다. 이러한 액션들은 기사들에 대한 CRUD 작업을 수행하게 된다.</p><div class="note"><p>루비에는 <code>public</code>, <code>private</code>, <code>protected</code> 메소드가 있지만 <code>public</code> 메소드만이 컨트롤러 액션으로 작업을 수행하게 된다. 더 자세한 내용은 <a href="http://www.ruby-doc.org/docs/ProgrammingRuby/">Programming Ruby</a>을 확인해 보기 바란다.</p></div><p>이제 <a href="http://localhost:3000/articles/new">http://localhost:3000/articles/new</a>를 다시 보기하면 새로운 에러를 보게 될 것이다.</p><p><img src="images/getting_started/unknown_action_new_for_articles.png" alt="Unknown action new for ArticlesController!"></p><p>이러한 에러는 방금 전에 생성한 <code>ArticlesController</code> 내에 <code>new</code> 액션이 정의되어 있지 않다는 것을 알려 준다. 이것은 컨트롤러의 생성과정에서 원하는 액션을 명시적으로 추가하지 않는 한 레일스가 컨트롤러를 비어 있는 상태로 생성하기 때문이다.</p><p>컨트롤러 내에 액션을 수작업으로 정의하기 위해서는 단지 해당 컨트롤러 내에 새로운 메소드를 정의하면 된다. <code>app/controllers/articles_controller.rb</code> 파일을 열고 <code>ArticlesController</code> 클래스 내에 <code>new</code> 메소드를 정의하면 아래와 같이 보이게 된다.</p><div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
class ArticlesController &lt; ApplicationController
  def new
  end
end

</pre>
</div>
<p>이 상태에서 <a href="http://localhost:3000/articles/new">http://localhost:3000/articles/new</a>를 새로 보기하면 또 다른 에러를 보게 될 것이다.</p><p><img src="images/getting_started/template_is_missing_articles_new.png" alt="Template is missing for articles/new"></p><p>레일스는 이와 같은 단순한 액션이 자신의 정보를 표시하기 위해 이와 연과되는 뷰를 가지는 것으로 기대하기 때문에 이런 에러가 발생하는 것이다. 뷰가 없다면 레일스는 예외를 발생할 것이다.</p><p>다시 전체 에러 메시지를 살펴 보자.</p>
<blockquote>
<p>ArticlesController#new 액션은 다음의 요청 포맷으로 작성된 템플릿 파일이 누락되어 있다: text/html</p>
<p>NOTE!
별도로 이름을 명시하지 않는 한, 레일스는 컨트롤러 이름과 동일한 폴더 내에 액션 이름과 동일한 템플릿 파일을 만들어 줄 것으로 기대한다. 이 컨트롤러가 204(컨텐츠 없음) 응답 상태를 보내는 API일 경우에는 이러한 템플릿 파일이 필요없지만, 브라우저 상에서 이 컨트롤러에 접근할 때는 HTML 템플릿이 요구되기 때문에 이런 에러 메시지를 보이게 된다. 그런 경우라면 계속해서 작업을 진행하면 된다.</p>
</blockquote>
<p>이 메시지는 어떤 템플릿 파일이 누락되었는지 알려 준다. 이 경우는 <code>articles/new</code> 템플릿 파일이 해당된다. 레일스는 먼저 이 템플릿 파일을 찾게 되고 해당 위치에 없을 경우, <code>ArticlesController</code>가 <code>AppllicationController</code>로부터 상속을 받기 때문에 <code>application/new</code> 템플릿 파일을 로드하려고 시도할 것이다.</p><p>다음으로 메시지 내용 중에는 <code>request.formats</code>가 포함되어 있는데, 이것은 응답으로 내보낼 템플릿 파일의 포맷을 명시하는 것이다. 브라우저를 통해서 이 페이지를 요청했기 때문에 <code>text/html</code>로 설정되어 있다. 따라서 레일스는 HTML 포맷의 템플릿 파일을 찾게 된다.</p><p>이 경우에 동작하게 될 가장 단순한 템플릿 파일은 <code>app/views/articles/new.html.erb</code>에 위치하게 될 것이다. 이 파일명의 확장자명이 중요한데, 첫번째 확장자(.html)는 템플릿의 <em>포맷</em> 이고 두번째 확장자는 템플릿을 최종적으로 작성할 때 사용하는 <em>핸들러</em> 를 의미한다. 레일스는 애플리케이션의 <code>app/views</code> 폴더 내 <code>articles/new</code> 템플릿 파일을 찾게 된다. 이 템플릿의 포맷은 <code>html</code>이고 HTML 포맷에 대한 기본 핸들러는 <code>erb</code>이라고 해석하게 된다. 다른 포맷에 대해서 다른 핸들러를 사용하게 된다. <code>builder</code> 핸들러는 XML 템플릿을 빌드하고 <code>coffee</code> 핸들러는 자바스크립트 템플릿을 빌드하는데 사용할 수 있다. HTML 폼을 새로 만들기 원하기 때문에 HTML 문서에 루비 언어를 임베드하기 위해 만들어진 <code>ERB</code> 언어를 사용할 것이다.</p><p>따라서, 파일명은 <code>articles/new.html.erb</code> 이어야 하고 애플리케이션의 <code>app/views</code> 디렉토리 내에 위치해야 한다.</p><p>이제 <code>app/views/articles/new.html.erb</code> 위치에 새로운 파일을 생성하고 아래와 같이 작성한다.</p><div class="code_container">
<pre class="brush: xml; gutter: false; toolbar: false">
&lt;h1&gt;New Article&lt;/h1&gt;

</pre>
</div>
<p><a href="http://localhost:3000/articles/new">http://localhost:3000/articles/new</a>를 새로 보기하면 하나의 타이틀을 포함하는 페이지를 보게 될 것이다. 라우트, 컨트롤러, 액션, 뷰가 조화롭게 잘 동작하고 있는 것이다. 새로운 기사를 작성할 폼을 생성할 시점이 되었다.</p><h4 id="the-first-form"><a class="anchorlink" href="#the-first-form">5.2 첫번째 폼</a></h4><p>이 템플릿 파일에 폼을 생성하기 위해 <em>폼 빌더</em> 를 사용할 것이다. 레일스에서 사용하는 기본 폼 빌더는 <code>form_with</code> 헬퍼메소드가 제공해 준다. 이 메소드를 사용하기 위해서는 아래의 코드를 <code>app/views/articles/new.html.erb</code> 파일에 추가해 준다.</p><div class="code_container">
<pre class="brush: ruby; html-script: true; gutter: false; toolbar: false">
&lt;%= form_with scope: :article, local: true do |form| %&gt;
  &lt;p&gt;
    &lt;%= form.label :title %&gt;&lt;br&gt;
    &lt;%= form.text_field :title %&gt;
  &lt;/p&gt;

  &lt;p&gt;
    &lt;%= form.label :text %&gt;&lt;br&gt;
    &lt;%= form.text_area :text %&gt;
  &lt;/p&gt;

  &lt;p&gt;
    &lt;%= form.submit %&gt;
  &lt;/p&gt;
&lt;% end %&gt;

</pre>
</div>
<p>이제 이 페이지를 다시 보기하면 위의 예제에서 보았던 것과 동일한 폼을 보게 될 것이다. 
레일스에서 폼을 빌드하는 것은 정말 이렇게도 쉽다!</p><p><code>form_with</code> 메소드를 호출할 때 이 폼에 대한 식별용 스코프를 지정한다. 이 경우에는 심볼 형태인 <code>:article</code>로 지정한다. 이것은 <code>form_with</code> 헬퍼에게 이 폼의 용도를 알려 주는 것이다. 이 메소드의 블록 내에서는 <code>form</code> 블록변수로 표시되는 <code>FormBuilder</code> 객체를 이용하여 기사 title과 text 용으로 두 개의 라벨과 두 개의 텍스트 필드를 빌드한다. 최종적으로 <code>form</code> 객체에 대해서 <code>submit</code> 메소드를 호출하여 폼에서 사용하게 되는 서밋 버튼을 생성하게 된다.</p><p>그러나 이 폼에서는 한가지 문제가 있다. 페이지의 소스보기에서 헬프메소드로 생성된 HTML을 조사해 보면 form 태그의 <code>action</code> 속성이 <code>articles/new</code>로 지정된 것을 알 수 있다. 이 라우트가 현재 폼이 위치하는 바로 그 페이지를 가리키기 때문이다. 이 라우트는 새로운 기사를 입력하기 위한 폼을 표시하기 위해서만 사용되어야 한다.</p><p>이 폼이 또 다른 곳으로 이동하기 위해서는 다른 URL을 사용해야 한다. 이 작업은 <code>form_with</code> 메소드에 <code>:url</code> 옵션을 지정함으로써 바로 해결할 수 있다. 레일스에서 보통, 이와 같이 새로운 폼 데이터를 서밋할 때 사용하는 액션을 "create"라고 부르는데 폼은 바로 이 액션으로 서밋되도록 해야 한다.</p><p>app/views/articles/new.html.erb<code>파일에 있는</code>form_with`를 아래와 같이 보이도록 수정한다.</p><div class="code_container">
<pre class="brush: ruby; html-script: true; gutter: false; toolbar: false">
&lt;%= form_with scope: :article, url: articles_path, local: true do |form| %&gt;

</pre>
</div>
<p>이 예문에서는 <code>:url</code> 옵션으로 <code>articles_path</code> 헬퍼를 넘겨준다. 이러한 작업으로 초래되는 결과를 보기 위해서 <code>rails routes</code>의 결과를 다시 보도록 한다.</p><div class="code_container">
<pre class="brush: plain; gutter: false; toolbar: false">
$ rails routes
      Prefix Verb   URI Pattern                  Controller#Action
welcome_index GET    /welcome/index(.:format)     welcome#index
     articles GET    /articles(.:format)          articles#index
              POST   /articles(.:format)          articles#create
  new_article GET    /articles/new(.:format)      articles#new
 edit_article GET    /articles/:id/edit(.:format) articles#edit
      article GET    /articles/:id(.:format)      articles#show
              PATCH  /articles/:id(.:format)      articles#update
              PUT    /articles/:id(.:format)      articles#update
              DELETE /articles/:id(.:format)      articles#destroy
         root GET    /                            welcome#index

</pre>
</div>
<p><code>articles_path</code> 헬퍼는 폼이 <code>articles</code> 접두어(prefix)와 연관되는 URI 패턴을 가리키도록 하는데 이 때 폼은 기본상태에서 해당 라우트로 <code>POST</code> 요청을 보내게 된다. 이 라우트는 <code>ArticlesController</code> 컨트롤러의 <code>create</code> 액션과 연결된다.</p><p>폼과 라우트가 지정된 상태에서 폼에 데이터를 입력한 후 서밋 버튼을 클릭하면 새 기사를 생성하는 과정을 시작하게 된다. 언급한 바와 같이 폼을 서밋하면 익숙한 에러 메시지를 보게 된다.</p><p><img src="images/getting_started/unknown_action_create_for_articles.png" alt="Unknown action create for ArticlesController"></p><p>이제 이것이 제대로 동작하도록 하려면 <code>ArticlesController</code> 내에 <code>create</code> 액션을 작성해야 한다.</p><div class="note"><p>보통은 <code>form_with</code> 헬퍼는 Ajax로 폼을 서밋하게 되므로 전체 페이지 리디렉션이 발생하지 않는다. 현재는 이 가이드를 보다 쉽게 이해할 수 있도록 <code>local: true</code>로 옵션을 지정하여 이 기능을 사용하지 않도록 했다.</p></div><h4 id="creating-articles"><a class="anchorlink" href="#creating-articles">5.3 기사 작성하기</a></h4><p>"Unknow action" 에러 메시지가 사라지게 하려면, 아래와 같이 <code>app/controllers/articles_controller.rb</code> 파일 내의 <code>ArticlesController</code> 클래스에서, <code>new</code> 액션 바로 아래에, <code>create</code> 액션을 정의한다.</p><div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
class ArticlesController &lt; ApplicationController
  def new
  end

  def create
  end
end

</pre>
</div>
<p>이제 다시 폼 서밋하면 페이지상에 아무런 변화를 볼 수 없을 것이다. 잘 못 된 것은 아니므로 걱정할 필요 없다. 응답으로 보낼 내용이 없는 경우 레일스는 보통 <code>204 No Content(내용 없음)</code> 응답을 보내기 때문이다. 단지 <code>create</code> 액션만 추가한 후 응답으로 보낼 내용을 작성하지 않았다. 이 경우에는, <code>create</code> 액션은 데이터베이스로 새로 작성한 기사를 저장하도록 해야 한다.</p><p>폼이 서밋될 때, 폼 필드는 <em>매개변수(parameters)</em> 로써 레일스로 보내진다. 이 매개변수들은 어떤 특정 일을 수행하기 위해 컨트롤러 액션에서 참조할 수 있다. 이 매개변수들의 상태를 보기 위해 아래와 같이 <code>create</code> 액션을 수정한다.</p><div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
def create
  render plain: params[:article].inspect
end

</pre>
</div>
<p>여기서 <code>render</code> 메소드는 <code>:plain</code> 키와 <code>params[:article].inspect</code> 값을 가지는 매우 단순한 해시를 인수로 받는다. <code>params</code> 메소드는 폼에서부터 넘어오는 매개변수(또는 폼 필드)를 나타내는 객체이다. <code>params</code> 메소드는 <code>ActionController::Parameters</code> 객체를 반환하는데, 이 객체로서 문자열이나 심볼을 이용하여 해시 키에 접근할 수 있도록 한다. 이 경우에 중요한 매개변수들은 폼으로부터 넘어 오는 것들 뿐이다.</p><div class="info"><p><code>params</code> 메소드를 꽤나 일상적으로 사용할 것이기 때문에 확실하게 파악해 둘 필요가 있다. <strong><a href="http://www.example.com/?username=dhh&amp;email=dhh@email.com">http://www.example.com/?username=dhh&amp;email=dhh@email.com</a></strong> 와 같은 URL을 예로 들어 보자. 이 URL에서 <code>params[:username]</code>은 "dhh"가 될 것이고 <code>params[:email]</code>은 "<a href="mailto:dhh@email.com">dhh@email.com</a>"가 될 것이다.</p></div><p>한번 더 폼을 다시 서밋하면 아래와 같은 것을 보게 될 것이다.</p><div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
&lt;ActionController::Parameters {"title"=&gt;"First Article!", "text"=&gt;"This is my first article."} permitted: false&gt;

</pre>
</div>
<p>이 액션은 폼으로부터 넘어 오는 해당 기사에 대한 매개변수를 보여 준다. 그러나 이것은 실제로 그렇게 유용하지 못하다. 그렇다. 매개변수들을 볼 수 있지만 그것들을 이용하여 특별히 작업한 것이 전혀 없다.</p><h4 id="creating-the-article-model"><a class="anchorlink" href="#creating-the-article-model">5.4 Article 모델 생성하기</a></h4><p>레일스에서는 모델 이름을 단수형으로 사용하고 해당 데이터베이스 테이블명으로는 복수형을 사용한다. 레일스는 모델을 생성하는 생성자 스크립트를 제공하는데 대부분의 레일스 개발자들은 새로운 모델을 작성할 때 이것을 사용하려고 한다. 새로운 모델을 작성할 때는 터미널에서 아래의 명령을 실행한다.</p><div class="code_container">
<pre class="brush: plain; gutter: false; toolbar: false">
$ rails generate model Article title:string text:text

</pre>
</div>
<p>이 명령으로써 문자형의 <em>title</em> 속성과 텍스트 속성의 <em>text</em> 속성을 가지는 <code>Article</code> 모델을 원한다고 레일스에게 알려주게 된다. 이 속성들은 자동으로 데이터베이스 <code>articles</code> 테이블에 추가되어 <code>Article</code> 모델로 매핑된다.</p><p>레일스 다수의 파일들을 생성하므로써 응답을 보이게 된다. 현재로서는 <code>app/models/article.rb</code> 와 <code>db/migrate/20140120191729_create_articles.rb</code> 파일(각자 파일명에 차이가 있을 수 있음)에만 집중하도록 한다. 후자는 데이터베이스 구조를 정의하는 것을 담당하는데 이것은 다음에 살펴 보도록 한다.</p><div class="info"><p>액티브 레코드는 매우 스마트해서 자동으로 컬럼명을 모델 속성으로 매핑해 주는데, 이것은 액티브 레코드가 자동으로 해 주기 때문에 레일스 모델 내에서 속성들을 따로 선언해 줄 필요가 없다는 것을 뜻한다.</p></div><h4 id="running-a-migration"><a class="anchorlink" href="#running-a-migration">5.5 마이그레이션 작업 수행하기</a></h4><p>방금 보았듯이 <code>rails generate model</code> 명령으로 <code>db/migrate</code> 디렉토리 내에 <em>데이터베이스 마이그레이션</em> 파일이 생성되었다. 마이그레이션을 데이터베이스 테이블을 생성하고 변경하는 작업을 쉽게 해 주기 위해 작성된 루비 클래스이다. 레일스는 rake 명령을 사용하여 마이그레이션 작업을 수행하며 데이터베이스에 적용이 완료된 후에도 마이그레이션을 취소할 수도 있다. 마이그레이션 파일명은 타임스탬프를 포함하는데 생성된 순서대로 마이그레이션으로 처리하기 위한 것이다.</p><p><code>db/migrate/YYYYMMDDHHMMSS_create_articles.rb</code> 파일(각자의 파일명이 다를 수 있음)의 내용은 아래와 같을 것이다.</p><div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
class CreateArticles &lt; ActiveRecord::Migration[6.0]
  def change
    create_table :articles do |t|
      t.string :title
      t.text :text

      t.timestamps
    end
  end
end

</pre>
</div>
<p>위의 마이그레이션에서 작성되는 <code>change</code> 메소드는 마이그레이션 작업이 수행될 때 호출된다. 이 메소드에서 정의된 작업 또한 가역적이며 이것은 나중에 되돌리기를 원할 경우 레일스가 마이그레이션으로 변경된 내용을 되돌릴 수 있는 방법을 알고 있다는 것을 의미한다. 이 마이그레이션을 수행하면 하나의 문자열 컬럼과 텍스트 컬럼을 가지는 <code>articles</code> 테이블을 생성하게 될 것이다. 또한 두 개의 타임스탬프 필드도 생성하는데 레일스가 기사를 생성하고 업데이트하는 시간을 추적하는데 사용된다.</p><div class="info"><p>마이그레이션에 대한 더 많은 정보를 원할 경우 <a href="active_record_migrations.html">Active Record Migrations</a>를 참고한다.</p></div><p>이 지점에서 아래와 같이 레일스 명령을 사용하여 마이그레이션 작업을 수행할 수 있다.</p><div class="code_container">
<pre class="brush: plain; gutter: false; toolbar: false">
$ rails db:migrate

</pre>
</div>
<p>레일스는 이 마이그레이션 명령을 실행한 후 Articles 테이블이 생성되었음을 알려 줄 것이다.</p><div class="code_container">
<pre class="brush: plain; gutter: false; toolbar: false">
==  CreateArticles: migrating ==================================================
-- create_table(:articles)
   -&gt; 0.0019s
==  CreateArticles: migrated (0.0020s) =========================================

</pre>
</div>
<div class="note"><p>보통 개발 환경에서 작업을 할 것이기 때문에 <code>config/database.yml</code> 파일의 <code>development</code> 섹션에 정의된 데이터베이스에 마이그레이션 작업이 적용될 것이다. 다른 환경에서 마이그레이션을 실행하고자 할 경우, 예를 들어 운영 환경에서, <code>rails db:migrate RAILS_ENV=production</code>와 같이 명령을 호출할 때 명시적으로 지정해 주어야 한다.</p></div><h4 id="saving-data-in-the-controller"><a class="anchorlink" href="#saving-data-in-the-controller">5.6 컨트롤러에서 데이터 저장하기</a></h4><p>새로 생성한 <code>Article</code> 모델을 이용하여 데이터베이스로 데이터를 저장하기 위해서는 <code>ArticlesController</code>로 돌아가서 <code>create</code> 액션을 변경할 필요가 있다. <code>app/controllers/articles_controller.rb</code> 파일을 열고 아래와 같이 <code>create</code> 액션을 변경한다.</p><div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
def create
  @article = Article.new(params[:article])

  @article.save
  redirect_to @article
end

</pre>
</div>
<p>위에서 일어난 상황을 설명하면 다음과 같다. 모든 레일스 모델은 각각의 데이터베이스 테이블 컬럼으로 자동으로 매핑되는 각각의 속성으로 초기화될 수 있다. 첫번째 코드라인에서 이런 작업을 하게 된다(<code>params[:article]</code>에는 관심있는 속성들이 포함되어 있다는 것을 기억한다). 다음으로 <code>@article.save</code>은 모델을 데이터베이스에 저장한다. 마지막으로 사용자를 <code>show</code> 액션으로 리디렉션하는데 이것은 나중에 정의할 것이다.</p><div class="info"><p>이 가이드에서 기사들에 대한 대부분의 다른 참조는 소문자를 사용했던 반면, <code>Article.new</code>에서는 <code>A</code>를 대문자로 표시한 점에 대해서 궁금할 수 있다. 여기서는 <code>app/models/article.rb</code>에 정의 된 <code>Article</code> 클래스를 참조한다. 루비의 클래스 이름은 대문자로 시작해야 한다.</p></div><div class="info"><p>나중에 알게 되겠지만 <code>@article.save</code>는 기사가 저장되었는지 여부를 부울 값(true/false)으로 반환한다.</p></div><p><a href="http://localhost:3000/articles/new">http://localhost:3000/articles/new</a>로 이동하면 기사를 <em>거의</em> 생성할 수 있게 될 것이다. 이와 같이 시도할 경우 아래와 같은 에러 메시지를 보게 될 것이다.</p><p><img src="images/getting_started/forbidden_attributes_for_new_article.png" alt="Forbidden attributes for new article"></p><p>레일스에는 보안상 안전한 프로그램을 작성하는데 도움이되는 몇 가지 보안 기능이 있으며 이제 그 중 하나를 사용할 것이다. 이것은 <a href="action_controller_overview.html#strong-parameters">strong parameters</a>라고 하는 것인데 컨트롤러 동작에 어떤 파라미터가 허용되는지 레일스에게 정확히 알려 준다.</p><p>왜 이렇게 귀찮은 과정을 거쳐야 할까? 모든 컨트롤러 파라미터를 한꺼번에 취합해서 모델로 자동 할당할 수 있다면 프로그래밍 작업을 더 쉽게 할 수 있겠지만 이 간편함은 역시 악의적인 용도로 사용될 수 있다. 서버에 대한 요청이 새로운 기사를 폼 서밋하는 것처럼 보이도록 조작되고 애플리케이션의 무결성을 위반하는 값을 가진 별도의 필드가 포함되었다면 어떻게 될까? 그것들은 기사 속성들과 함께 모델에서 데이터베이스로 '대량 할당' 되어 애플리케이션을 손상 시키거나 악화시킬 수 있을 것이다.</p><p>잘못된 대량 할당을 방지하기 위해서 허용되는 컨트롤러 매개변수를 정의해야 한다. 여기서는 <code>create</code>를 유효하게 사용하기 위해 <code>title</code> 및 <code>text</code> 매개 변수를 허용하고 필수항목으로 지정한다. 이를 위한 문법으로 <code>require</code>와 <code>permit</code>을 도입한다. <code>create</code> 액션에 아래와 같이 한 줄을 포함할 것이다.</p><div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
  @article = Article.new(params.require(:article).permit(:title, :text))

</pre>
</div>
<p>이것은 종종 별도의 메소드로 분리되어 동일한 컨트롤러 내의 여러 액션(예 :<code>create</code> 및<code>update</code>)에서 재사용 되기도 한다. 이 메소드는 대량 할당 문제를 해결할 뿐만 아니라 종종 의도된 경우 외에는 호출될 수 없도록 <code>private</code>로 선언한다. 아래에 그 결과를 보여 준다.</p><div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
def create
  @article = Article.new(article_params)

  @article.save
  redirect_to @article
end

private
  def article_params
    params.require(:article).permit(:title, :text)
  end

</pre>
</div>
<div class="info"><p>자세한 내용은 위의 레퍼런스 및 <a href="ttps://weblog.rubyonrails.org/2012/3/21/strong-parameters/">Strong Paramters에 대한 이 블로그의 관련 기사</a>를 참고한다.</p></div><h4 id="showing-articles"><a class="anchorlink" href="#showing-articles">5.7 기사 보여주기</a></h4><p>지금 폼을 다시 서밋하면 레일스는 <code>show</code> 액션를 찾지 못한다고 불평할 것이다. 그다지 유용하지는 않더라도 계속하기 전에 <code>show</code> 액션을 추가하도록 한다.</p><p><code>rails routes</code>의 결과에서 보았 듯이 <code>show</code> 액션의 라우트는 다음과 같다.</p><div class="code_container">
<pre class="brush: plain; gutter: false; toolbar: false">
article GET    /articles/:id(.:format)      articles#show

</pre>
</div>
<p>특수한 문법인 <code>:id</code> 는 이 라우트가 <code>:id</code> 매개 변수를 필요로 한다는 것을 레일스에 알려 주는데 이 경우에는 기사의 ID가 된다.</p><p>이전과 마찬가지로 <code>app/controllers/articles_controller.rb</code>의 <code>show</code> 액션과 해당 뷰를 추가해야 한다.</p><div class="note"><p>자주 사용하는 방법은 표준 CRUD 작업을 각 컨트롤러에 <code>index</code>, <code>show</code>, <code>new</code>, <code>edit</code>, <code>create</code>, <code>update</code> 및 <code>destroy</code> 순서로 배치하는 것이다. 각자가 임의로 순서를 변경할 수 있지만 이 메소드들은 public 메소드라는 점을 기억해 둔다. 이 가이드의 앞부분에서 언급했듯이 컨트롤러 상에 <code>private</code>를 선언하기 전에 배치해야 한다.</p></div><p>이를 감안하여 아래와 같이<code>show</code> 액션을 추가하자.</p><div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
class ArticlesController &lt; ApplicationController
  def show
    @article = Article.find(params[:id])
  end

  def new
  end

  # snippet for brevity

</pre>
</div>
<p>몇 가지 유의할 사항. <code>Article.find</code>를 사용하여 요청에서 <code>:id</code> 매개 변수를 얻기 위해 <code>params[:id]</code>를 전달하여 관심있는 기사를 찾는다. 또한 기사 객체에 대한 참조를 유지하기 위해 인스턴스 변수(<code>@</code> 접두사)를 사용한다. 레일스가 모든 인스턴스 변수를 뷰에 전달하기 때문에 이 작업을 수행한다.</p><p>이제 다음 내용으로 새 파일 <code>app/views/articles/show.html.erb</code>를 작성한다.</p><div class="code_container">
<pre class="brush: ruby; html-script: true; gutter: false; toolbar: false">
&lt;p&gt;
  &lt;strong&gt;Title:&lt;/strong&gt;
  &lt;%= @article.title %&gt;
&lt;/p&gt;

&lt;p&gt;
  &lt;strong&gt;Text:&lt;/strong&gt;
  &lt;%= @article.text %&gt;
&lt;/p&gt;

</pre>
</div>
<p>이와 같이 변경한 후 비로서 기사를 새로 작성할 수 있게 되는 것이다.
이제 <a href="http://localhost:3000/articles/new">http://localhost:3000/articles/new</a>를 방문하여 직접 사용해 보기 바란다!</p><p><img src="images/getting_started/show_action_for_articles.png" alt="Show action for articles"></p><h4 id="listing-all-articles"><a class="anchorlink" href="#listing-all-articles">5.8 모든 기사 목록 보기</a></h4><p>모든 기사를 나열할 방법도 필요하므로 함께 진행하도록 하자.
<code>rails routes</code>의 결과에 따른 라우트는 아래와 같다.</p><div class="code_container">
<pre class="brush: plain; gutter: false; toolbar: false">
articles GET    /articles(.:format)          articles#index

</pre>
</div>
<p><code>app/controllers/articles_controller.rb</code> 파일의 <code>ArticlesController</code> 내에 해당 라우트로 연결되는 <code>index</code> 액션을 추가한다. <code>index</code> 액션을 작성할 때는 습관적으로 컨트롤러 내에 첫 번째 메소드로 배치한다. 아래와 같이 작성한다.</p><div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
class ArticlesController &lt; ApplicationController
  def index
    @articles = Article.all
  end

  def show
    @article = Article.find(params[:id])
  end

  def new
  end

  # snippet for brevity

</pre>
</div>
<p>마지막으로 이 액션에 대한 뷰를 추가한다. 이 뷰 파일은 <code>app/views/articles/index.html.erb</code>에 위치한다.</p><div class="code_container">
<pre class="brush: ruby; html-script: true; gutter: false; toolbar: false">
&lt;h1&gt;Listing articles&lt;/h1&gt;

&lt;table&gt;
  &lt;tr&gt;
    &lt;th&gt;Title&lt;/th&gt;
    &lt;th&gt;Text&lt;/th&gt;
    &lt;th&gt;&lt;/th&gt;
  &lt;/tr&gt;

  &lt;% @articles.each do |article| %&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;%= article.title %&gt;&lt;/td&gt;
      &lt;td&gt;&lt;%= article.text %&gt;&lt;/td&gt;
      &lt;td&gt;&lt;%= link_to 'Show', article_path(article) %&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;% end %&gt;
&lt;/table&gt;

</pre>
</div>
<p>이제 <a href="http://localhost:3000/articles">http://localhost:3000/articles</a>로 이동하면 지금까지 작성한 모든 기사 목록이 표시될 것이다.</p><h4 id="adding-links"><a class="anchorlink" href="#adding-links">5.9 링크 추가하기</a></h4><p>이제 기사를 작성하고 보여주고 목록을 나열할 수 있게 되었다. 다음으로 페이지간의 이동을 위한 몇가지 링크를 추가해 보도록 하자.</p><p><code>app/views/welcome/index.html.erb</code> 파일을 열고 아래와 같이 변경한다.</p><div class="code_container">
<pre class="brush: ruby; html-script: true; gutter: false; toolbar: false">
&lt;h1&gt;Hello, Rails!&lt;/h1&gt;
&lt;%= link_to 'My Blog', controller: 'articles' %&gt;

</pre>
</div>
<p><code>link_to</code> 메소드는 레일스의 내장 뷰 헬퍼 중 하나이다. 표시할 텍스트와 이동 위치(이 경우 기사 목록에 대한 경로)를 기반으로 하이퍼링크를 생성한다.</p><p>이 "New Article" 링크를 <code>app/views/articles/index.html.erb</code>에 추가하여 다른 뷰에 대한 링크를 추가하고 <code>&lt;table&gt;</code> 태그 위에 배치해 보자.</p><div class="code_container">
<pre class="brush: ruby; html-script: true; gutter: false; toolbar: false">
&lt;%= link_to 'New article', new_article_path %&gt;

</pre>
</div>
<p>이 링크를 사용하면 새 기사를 작성할 수 있는 폼을 불러올 수 있다.</p><p>이제 <code>app/views/articles/new.html.erb</code> 파일 내의 폼 아래에 또 다른 링크를 추가하여 <code>index</code> 액션으로 돌아 갈 수 있도록 한다.</p><div class="code_container">
<pre class="brush: ruby; html-script: true; gutter: false; toolbar: false">
&lt;%= form_with scope: :article, url: articles_path, local: true do |form| %&gt;
  ...
&lt;% end %&gt;

&lt;%= link_to 'Back', articles_path %&gt;

</pre>
</div>
<p>마지막으로, <code>app/views/articles/show.html.erb</code> 템플릿에 링크를 추가하여 <code>index</code> 액션으로 돌아갈 수 있도록 하면 단일 기사를 보는 상태에서 되돌아 가서 다시 전체 목록을 볼 수 있게 된다.</p><div class="code_container">
<pre class="brush: ruby; html-script: true; gutter: false; toolbar: false">
&lt;p&gt;
  &lt;strong&gt;Title:&lt;/strong&gt;
  &lt;%= @article.title %&gt;
&lt;/p&gt;

&lt;p&gt;
  &lt;strong&gt;Text:&lt;/strong&gt;
  &lt;%= @article.text %&gt;
&lt;/p&gt;

&lt;%= link_to 'Back', articles_path %&gt;

</pre>
</div>
<div class="info"><p>레일스는 기본적으로 현재 컨트롤러를 사용하기 때문에 동일한 컨트롤러에서 액션에 연결하고자 할 경우 <code>:controller</code> 옵션을 지정할 필요가 없다.</p></div><div class="info"><p>개발 모드(기본적으로 작업중인 모드)에서 레일스는 모든 브라우저 요청에 따라 애플리케이션을 다시 로드하므로 소스 코드의 변경시 웹 서버를 중지했다가 다시 시작할 필요가 없다.</p></div><h4 id="adding-some-validation"><a class="anchorlink" href="#adding-some-validation">5.10 몇가지 유효성 검사 추가하기</a></h4><p><code>app/models/article.rb</code> 모델 파일은 아래와 같이 간단하다.</p><div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
class Article &lt; ApplicationRecord
end

</pre>
</div>
<p>이 파일에는 그다지 많은 내용이 있지 않지만 <code>Article</code> 클래스가 <code>ApplicationRecord</code>로부터 상속 받는다는 것에 주목한다. <code>ApplicationRecord</code>는, 기본 데이터베이스 CRUD (Create, Read, Update, Destroy) 작업, 데이터 유효성 검사, 정교한 검색 지원 및 여러 모델을 서로 연관시키는 기능을 포함하여, 레일스 모델에 많은 기능을 무료로 제공하는 <code>ActiveRecord::Base</code>로부터 상속받는다.</p><p>레일스에는 모델로 보내는 데이터의 유효성 검사에 도움이 되는 메소드가 포함되어 있다.
<code>app/models/article.rb</code> 파일을 열고 아래와 같이 변경한다.</p><div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
class Article &lt; ApplicationRecord
  validates :title, presence: true,
                    length: { minimum: 5 }
end

</pre>
</div>
<p>이로써 모든 기사의 제목은 5자 이상이어야 한다. 레일스는 컬럼의 유무와 형식, 그리고 관련 객체의 존재 등 모델의 다양한 조건을 검증 할 수 있다. 유효성 검사는 <a href="active_record_validations.html">Active Record Validations</a>에 자세히 설명되어 있다.</p><p>유효성 검사가 설정된 상태에서 유효하지 않은 기사에 대해서 <code>@article.save</code>를 호출하면 <code>false</code>를 반환할 것이다. <code>app/controllers/articles_controller.rb</code>를 다시 열면 <code>create</code> 액션 내에서 <code>@article.save</code>를 호출 한 결과를 확인하지 않는다는 것을 알게 될 것이다.
이 상태에서 <code>@article.save</code>가 실패하면 사용자에게 폼을 다시 보여줘야 한다. 이를 위해서는 <code>app/controllers/articles_controller.rb</code>의 <code>new</code> 및 <code>create</code> 액션을 아래와 같이 변경한다.</p><div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
def new
  @article = Article.new
end

def create
  @article = Article.new(article_params)

  if @article.save
    redirect_to @article
  else
    render 'new'
  end
end

private
  def article_params
    params.require(:article).permit(:title, :text)
  end

</pre>
</div>
<p><code>new</code> 액션은 이제 인스턴스 변수 <code>@article</code>을 새로 생성하게 되는데, 잠시 후에 그 이유를 알게 될 것이다.</p><p><code>create</code> 액션 내에서 <code>save</code>가 <code>false</code>를 반환 할 때 <code>redirect_to</code> 대신 <code>render</code>를 사용하는 것을 주목한다. 렌더링될 때 <code>@article</code> 객체를  <code>new</code> 템플릿으로 다시 전달하기 위해 <code>render</code> 메소드를 사용하는 것이다.  이 렌더링은 폼 서밋과 동일한 요청 내에서 수행되지만 <code>redirect_to</code>는 브라우저에 다른 요청을 하도록 한다.</p><p><a href="http://localhost:3000/articles/new">http://localhost:3000/articles/new</a>를 다시 로드하고 title 없이 기사를 저장하려고 하면 검증 오류로 인하여 다시 폼이 렌더링 되지만 이에 대한 유용한 정보를 제공해 주지 못한다. 사용자에게 무언가 잘못되었다고 알려 주어야 한다. 이를 위해 <code>app/views/articles/new.html.erb</code>를 수정하여 오류 메시지가 발생한 경우 표시하도록 한다.</p><div class="code_container">
<pre class="brush: ruby; html-script: true; gutter: false; toolbar: false">
&lt;%= form_with scope: :article, url: articles_path, local: true do |form| %&gt;

  &lt;% if @article.errors.any? %&gt;
    &lt;div id="error_explanation"&gt;
      &lt;h2&gt;
        &lt;%= pluralize(@article.errors.count, "error") %&gt; prohibited
        this article from being saved:
      &lt;/h2&gt;
      &lt;ul&gt;
        &lt;% @article.errors.full_messages.each do |msg| %&gt;
          &lt;li&gt;&lt;%= msg %&gt;&lt;/li&gt;
        &lt;% end %&gt;
      &lt;/ul&gt;
    &lt;/div&gt;
  &lt;% end %&gt;

  &lt;p&gt;
    &lt;%= form.label :title %&gt;&lt;br&gt;
    &lt;%= form.text_field :title %&gt;
  &lt;/p&gt;

  &lt;p&gt;
    &lt;%= form.label :text %&gt;&lt;br&gt;
    &lt;%= form.text_area :text %&gt;
  &lt;/p&gt;

  &lt;p&gt;
    &lt;%= form.submit %&gt;
  &lt;/p&gt;

&lt;% end %&gt;

&lt;%= link_to 'Back', articles_path %&gt;

</pre>
</div>
<p>여기서 처리되는 과정을 보면, <code>@article.errors.any?</code>를 호출하여 오류가 있는지 확인하고, 이 경우 <code>@article.errors.full_messages</code>로 모든 오류 목록을 표시하도록 한다.</p><p><code>pluralize</code>는 숫자와 문자열을 인수로 받는 레일스 헬퍼 메소드이다. 숫자가 1보다 크면 문자열이 복수형으로 자동변환된다.</p><p><code>ArticlesController</code>에 <code>@article = Article.new</code>를 추가한 이유는 그렇지 않을 경우 뷰 상에서 인스턴스 변수 <code>@article</code>의 값은 <code>nil</code>이 되고  이 때<code>@article.errors.any?</code>를 호출하면 에러가 발생하기 때문이다.</p><div class="info"><p>레일스는 <code>field_with_errors</code> 클래스가 지정되어 있는 div 태그로 에러를 포함하는 필드를 자동으로 래핑한다. CSS 규칙을 정의하여 이러한 필드를 두드러지게 보이게 할 수 있다.</p></div><p>이제 새 기사 폼 <a href="http://localhost:3000/articles/new">http://localhost:3000/articles/new</a>에서 title을 지정하지 않고 기사를 저장할 때 오류 메시지가 멋있게 표시될 것이다.</p><p><img src="images/getting_started/form_with_errors.png" alt="Form With Errors"></p><h4 id="updating-articles"><a class="anchorlink" href="#updating-articles">5.11 기사 업데이트하기</a></h4><p>지금까지 CRUD의 "CR"부분을 다뤘다. 이제 기사를 업데이트하면서 "U"부분에 초점을 맞추어 보자.</p><p>첫 번째 단계는 아래와 같이 <code>edit</code> 액션을 <code>ArticlesController</code>에 추가하는 것이다. 일반적으로 <code>new</code>와 <code>create</code> 액션 사이에 위치한다.</p><div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
def new
  @article = Article.new
end

def edit
  @article = Article.find(params[:id])
end

def create
  @article = Article.new(article_params)

  if @article.save
    redirect_to @article
  else
    render 'new'
  end
end

</pre>
</div>
<p>뷰에는 기사를 새로 작성할 때 사용한 것과 유사한 폼이 포함된다. <code>app/views/articles/edit.html.erb</code>라는 파일을 생성한 후 아래와 같이 추가한다.</p><div class="code_container">
<pre class="brush: ruby; html-script: true; gutter: false; toolbar: false">
&lt;h1&gt;Edit article&lt;/h1&gt;

&lt;%= form_with(model: @article, local: true) do |form| %&gt;

  &lt;% if @article.errors.any? %&gt;
    &lt;div id="error_explanation"&gt;
      &lt;h2&gt;
        &lt;%= pluralize(@article.errors.count, "error") %&gt; prohibited
        this article from being saved:
      &lt;/h2&gt;
      &lt;ul&gt;
        &lt;% @article.errors.full_messages.each do |msg| %&gt;
          &lt;li&gt;&lt;%= msg %&gt;&lt;/li&gt;
        &lt;% end %&gt;
      &lt;/ul&gt;
    &lt;/div&gt;
  &lt;% end %&gt;

  &lt;p&gt;
    &lt;%= form.label :title %&gt;&lt;br&gt;
    &lt;%= form.text_field :title %&gt;
  &lt;/p&gt;

  &lt;p&gt;
    &lt;%= form.label :text %&gt;&lt;br&gt;
    &lt;%= form.text_area :text %&gt;
  &lt;/p&gt;

  &lt;p&gt;
    &lt;%= form.submit %&gt;
  &lt;/p&gt;

&lt;% end %&gt;

&lt;%= link_to 'Back', articles_path %&gt;

</pre>
</div>
<p>이번에는 폼이 <code>update</code> 액션을 가리키도록 하는데, 아직 정의되지 않았지만 곧 될 것이다.</p><p><code>form_with</code> 메소드에 기사 객체를 전달하면 편집 된 기사 폼을 서밋하기 위한 URL이 자동으로 설정된다. 이 옵션을 사용하면 <code>PATCH</code> HTTP 메소드로 이 폼을 서밋할 수 있으며 이 메소드는 REST 프로토콜에 따라 리소스를 <strong>업데이트</strong>하는 데 사용하는 HTTP 메소드이다.</p><p>또한, 위의 편집 뷰에서 <code>model: @article</code>과 같이 <code>form_with</code>에 모델 객체를 전달하면 폼 헬퍼가 객체의 해당 값으로 폼 필드를 채우게 된다. new 뷰에서와 같이 <code>scope: :article</code>과 같은 심볼 스코프를 전달하면 빈 폼 필드 만 생성된다. 자세한 내용은 <a href="https://api.rubyonrails.org/6-0-stable/classes/ActionView/Helpers/FormHelper.html#method-i-form_with">form_with documentation</a>에서 찾아 볼 수 있다.</p><p>다음으로 <code>app/controllers/articles_controller.rb</code>에 <code>update</code> 액션을 만들어야 한다. <code>create</code> 액션과 <code>private</code> 메소드 사이에 추가한다.</p><div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
def create
  @article = Article.new(article_params)

  if @article.save
    redirect_to @article
  else
    render 'new'
  end
end

def update
  @article = Article.find(params[:id])

  if @article.update(article_params)
    redirect_to @article
  else
    render 'edit'
  end
end

private
  def article_params
    params.require(:article).permit(:title, :text)
  end

</pre>
</div>
<p>새로 작성하는 <code>update</code> 메소드는 이미 존재하는 레코드를 업데이트할 때 사용되며 업데이트하려는 속성을 포함하는 해시를 이용한다. 이전과 마찬가지로 기사를 업데이트하는 동안 오류가 발생하면 폼을 사용자에게 다시 보여 주도록 한다.</p><p>앞서 create 액션을 위해 정의했던 <code>article_params</code> 메소드를 재사용한다.</p><div class="info"><p>모든 속성을 <code>update</code>에 전달할 필요는 없다. 예를 들어, <code>@article.update(title: 'A new title')</code>이 호출되면 레일스는 <code>title</code> 속성 만 업데이트하고 다른 모든 속성은 변경하지 않는다.</p></div><p>마지막으로, 모든 기사 목록에서 <code>edit</code> 액션에 대한 링크를 보여 주기 위해서, 이제 <code>app/views/articles/index.html.erb</code>에 이 링크를 추가하여 "Show" 링크 옆에 보이도록 한다.</p><div class="code_container">
<pre class="brush: ruby; html-script: true; gutter: false; toolbar: false">
&lt;table&gt;
  &lt;tr&gt;
    &lt;th&gt;Title&lt;/th&gt;
    &lt;th&gt;Text&lt;/th&gt;
    &lt;th colspan="2"&gt;&lt;/th&gt;
  &lt;/tr&gt;

  &lt;% @articles.each do |article| %&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;%= article.title %&gt;&lt;/td&gt;
      &lt;td&gt;&lt;%= article.text %&gt;&lt;/td&gt;
      &lt;td&gt;&lt;%= link_to 'Show', article_path(article) %&gt;&lt;/td&gt;
      &lt;td&gt;&lt;%= link_to 'Edit', edit_article_path(article) %&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;% end %&gt;
&lt;/table&gt;

</pre>
</div>
<p>또한 <code>app/views/articles/show.html.erb</code> 템플릿에도 하나를 추가하여 기사 페이지에도 "Edit" 링크가 위치하게 된다. 템플릿 맨 아래에 추가한다.</p><div class="code_container">
<pre class="brush: ruby; html-script: true; gutter: false; toolbar: false">
...

&lt;%= link_to 'Edit', edit_article_path(@article) %&gt; |
&lt;%= link_to 'Back', articles_path %&gt;

</pre>
</div>
<p>그리고 지금까지 작업한 내용은 아래와 같다.</p><p><img src="images/getting_started/index_action_with_edit_link.png" alt="Index action with edit link"></p><h4 id="using-partials-to-clean-up-duplication-in-views"><a class="anchorlink" href="#using-partials-to-clean-up-duplication-in-views">5.12 파셜을 이용하여 뷰의 중복 코드 정리하기</a></h4><p><code>edit</code> 페이지는 <code>new</code> 페이지와 매우 유사하다. 실제로 둘 다 폼을 표시하기 위해 동일한 코드를 공유한다. 뷰 파셜을 사용하여 이러한 중복 코드를 제거할 수 있다. 일반적으로 파셜 파일의 이름은 밑줄로 시작된다.</p><div class="info"><p>파셜에 대한 자세한 내용은 <a href="layouts_and_rendering.html">Layouts and Rendering in Rails</a> 가이드를 읽어 보기 바란다.</p></div><p>아래의 내용으로 <code>app/views/articles/_form.html.erb</code> 파일을 새로 생성한다.</p><div class="code_container">
<pre class="brush: ruby; html-script: true; gutter: false; toolbar: false">
&lt;%= form_with model: @article, local: true do |form| %&gt;

  &lt;% if @article.errors.any? %&gt;
    &lt;div id="error_explanation"&gt;
      &lt;h2&gt;
        &lt;%= pluralize(@article.errors.count, "error") %&gt; prohibited
        this article from being saved:
      &lt;/h2&gt;
      &lt;ul&gt;
        &lt;% @article.errors.full_messages.each do |msg| %&gt;
          &lt;li&gt;&lt;%= msg %&gt;&lt;/li&gt;
        &lt;% end %&gt;
      &lt;/ul&gt;
    &lt;/div&gt;
  &lt;% end %&gt;

  &lt;p&gt;
    &lt;%= form.label :title %&gt;&lt;br&gt;
    &lt;%= form.text_field :title %&gt;
  &lt;/p&gt;

  &lt;p&gt;
    &lt;%= form.label :text %&gt;&lt;br&gt;
    &lt;%= form.text_area :text %&gt;
  &lt;/p&gt;

  &lt;p&gt;
    &lt;%= form.submit %&gt;
  &lt;/p&gt;

&lt;% end %&gt;

</pre>
</div>
<p><code>form_with</code> 선언을 제외한 모든 것은 동일하게 유지되었다.
이와 같이 더 짧고 간단한 <code>form_with</code> 선언을 다른 폼 중 하나에 사용할 수 있는 이유는 <code>@article</code>이 전체 RESTful 라우트 세트에 일치하는 <em>리소스</em>이고 레일스가 어떤 URI와 메소드를 사용할 것인지를 유추할 수 있기 때문이다.
<code>form_with</code> 사용에 대한 자세한 내용은 <a href="https://api.rubyonrails.org/6-0-stable/classes/ActionView/Helpers/FormHelper.html#method-i-form_with-label-Resource-oriented+style">Resource-oriented style</a>을 참조하기 바란다.</p><p>이제 이 파셜을 사용하도록 <code>app/views/articles/new.html.erb</code> 뷰를 완전히 다시 작성하여 업데이트 하자.</p><div class="code_container">
<pre class="brush: ruby; html-script: true; gutter: false; toolbar: false">
&lt;h1&gt;New article&lt;/h1&gt;

&lt;%= render 'form' %&gt;

&lt;%= link_to 'Back', articles_path %&gt;

</pre>
</div>
<p>그런 다음 <code>app/views/articles/edit.html.erb</code> 뷰에 대해 동일한 작업을 수행한다.</p><div class="code_container">
<pre class="brush: ruby; html-script: true; gutter: false; toolbar: false">
&lt;h1&gt;Edit article&lt;/h1&gt;

&lt;%= render 'form' %&gt;

&lt;%= link_to 'Back', articles_path %&gt;

</pre>
</div>
<h4 id="deleting-articles"><a class="anchorlink" href="#deleting-articles">5.13 기사 삭제하기</a></h4><p>이제 데이터베이스에서 기사를 삭제하는 CRUD의 "D"부분에 대해선 언급할 것이다. REST 규칙에 따른 <code>rails routes</code>의 결과를 근거로 기사 삭제 라우트는 아래와 같다.</p><div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
DELETE /articles/:id(.:format)      articles#destroy

</pre>
</div>
<p><code>delete</code> 라우팅 메소드는 리소스를 삭제하는 라우트에 사용해야 한다. 이것을 일반적인 <code>get</code> 라우트 그대로 남겨 둘 경우 사람들이 아래와 같은 악의적인 URL을 만들어 공격할 수 있다.</p><div class="code_container">
<pre class="brush: xml; gutter: false; toolbar: false">
&lt;a href='http://example.com/articles/1/destroy'&gt;look at this cat!&lt;/a&gt;

</pre>
</div>
<p>리소스 삭제 시에 <code>delete</code> 메소드를 사용하는데, 이 라우트는 아직 존재하지 않는 <code>app/controllers/articles_controller.rb</code> 내의 <code>destroy</code> 액션에 매핑된다. <code>destroy</code> 메소드는 일반적으로 컨트롤러 상에서 마지막 CRUD 액션이며 다른 public CRUD 액션과 마찬가지로 <code>private</code> 또는 <code>protected</code> 메소드 앞에 배치해야 한다. 아래와 같이 추가한다.</p><div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
def destroy
  @article = Article.find(params[:id])
  @article.destroy

  redirect_to articles_path
end

</pre>
</div>
<p><code>app/controllers/articles_controller.rb</code> 파일의 <code>ArticlesController</code>의 최종본은 이제 아래와 같아야 한다.</p><div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
class ArticlesController &lt; ApplicationController
  def index
    @articles = Article.all
  end

  def show
    @article = Article.find(params[:id])
  end

  def new
    @article = Article.new
  end

  def edit
    @article = Article.find(params[:id])
  end

  def create
    @article = Article.new(article_params)

    if @article.save
      redirect_to @article
    else
      render 'new'
    end
  end

  def update
    @article = Article.find(params[:id])

    if @article.update(article_params)
      redirect_to @article
    else
      render 'edit'
    end
  end

  def destroy
    @article = Article.find(params[:id])
    @article.destroy

    redirect_to articles_path
  end

  private
    def article_params
      params.require(:article).permit(:title, :text)
    end
end

</pre>
</div>
<p>데이터베이스에서 삭제하려는 경우 액티브 레코드 객체에서 <code>destroy</code>를 호출 할 수 있다. 주목할 것은 <code>index</code> 액션으로 리디렉션하기 때문에 이 액션에 대한 뷰를 추가 할 필요는 없다.</p><p>마지막으로 할 작업은, <code>index</code> 액션 템플릿(<code>app/views/articles/index.html.erb</code>)에 <code>Destroy</code> 링크를 추가하여 마무리 하는 것이다.</p><div class="code_container">
<pre class="brush: ruby; html-script: true; gutter: false; toolbar: false">
&lt;h1&gt;Listing Articles&lt;/h1&gt;
&lt;%= link_to 'New article', new_article_path %&gt;
&lt;table&gt;
  &lt;tr&gt;
    &lt;th&gt;Title&lt;/th&gt;
    &lt;th&gt;Text&lt;/th&gt;
    &lt;th colspan="3"&gt;&lt;/th&gt;
  &lt;/tr&gt;

  &lt;% @articles.each do |article| %&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;%= article.title %&gt;&lt;/td&gt;
      &lt;td&gt;&lt;%= article.text %&gt;&lt;/td&gt;
      &lt;td&gt;&lt;%= link_to 'Show', article_path(article) %&gt;&lt;/td&gt;
      &lt;td&gt;&lt;%= link_to 'Edit', edit_article_path(article) %&gt;&lt;/td&gt;
      &lt;td&gt;&lt;%= link_to 'Destroy', article_path(article),
              method: :delete,
              data: { confirm: 'Are you sure?' } %&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;% end %&gt;
&lt;/table&gt;

</pre>
</div>
<p>여기서는 다른 방식으로 <code>link_to</code>를 사용할 것이다. 네임드 라우트(named route, prefix가 있는 라우트)를 두 번째 인수로, 다른 옵션을 또 다른 인수로 전달한다.
<code>method: :delete</code> 및 <code>data: { confirm : 'Are you sure?' }</code> 옵션은 HTML5 속성으로 사용되기 때문에, 링크를 클릭할 경우 레일스는 먼저 사용자에게 확인창을 보여 준 다음, <code>delete</code> 메소드를 사용하여 링크를 서밋한다. 이것은 애플리케이션을 생성 할 때 애플리케이션 레이아웃 (<code>app/views/layouts/application.html.erb</code>)에 자동으로 포함되는 자바스크립트 파일 <code>rails-ujs</code>를 통해 수행된다. 이 파일이 없으면 확인창이 나타나지 않을 것이다.</p><p><img src="images/getting_started/confirm_dialog.png" alt="Confirm Dialog"></p><div class="info"><p><a href="working_with_javascript_in_rails.html">Working With JavaScript in Rails</a> 가이드에서 unobtrusive 자바스크립트에 대해 자세히 알 수 있다.</p></div><p>축하한다. 이제 기사를 작성, 보여주기, 리스트보기, 업데이트 및 삭제할 수 있게 되었다.</p><div class="info"><p>일반적으로 레일스는 라우트를 수동으로 선언하는 대신 리소스 객체를 사용하도록 권장한다. 라우팅에 대한 자세한 내용은 <a href="routing.html">Rails Routing from the Outside In</a>을 참조하기 바란다.</p></div><h3 id="adding-a-second-model"><a class="anchorlink" href="#adding-a-second-model">6 두번째 모델 추가하기</a></h3><p>이제 애플리케이션에 두 번째 모델을 추가할 때가 되었다. 두 번째 모델은 기사에 대한 댓글을 처리할 것이다.</p><h4 id="generating-a-model"><a class="anchorlink" href="#generating-a-model">6.1 모델 생성하기</a></h4><p><code>Article</code> 모델을 생성할 때 전에 사용했던 것과 같은 생성자를 사용할 것이다. 이번에는 기사에 대한 참조를 담는 <code>Comment</code> 모델을 생성할 것이다. 터미널에서 아래의 명령을 실행한다.</p><div class="code_container">
<pre class="brush: plain; gutter: false; toolbar: false">
$ rails generate model Comment commenter:string body:text article:references

</pre>
</div>
<p>이 명령은 4 개의 파일을 생성할 것이다.</p>
<table>
<thead>
<tr>
<th>파일</th>
<th>용도</th>
</tr>
</thead>
<tbody>
<tr>
<td>db/migrate/20140120201010_create_comments.rb</td>
<td>데이터베이스에 comments 테이블을 작성하기 위한 마이그레이션 (파일명에 각기 다른 타임스탬프가 포함됨)</td>
</tr>
<tr>
<td>app/models/comment.rb</td>
<td>Comment 모델</td>
</tr>
<tr>
<td>test/models/comment_test.rb</td>
<td>comment 모델의 기능 테스트하기</td>
</tr>
<tr>
<td>test/fixtures/comments.yml</td>
<td>테스트에 사용할 샘플 댓글</td>
</tr>
</tbody>
</table>
<p>먼저, <code>app/models/comment.rb</code> 파일 내용을 살펴 본다.</p><div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
class Comment &lt; ApplicationRecord
  belongs_to :article
end

</pre>
</div>
<p>이것은 앞서 본 <code>Article</code> 모델과 매우 유사하다. 차이점은 <code>belongs_to: article</code>이며, 액티브레코드 <em>association(관계)</em> 을 설정한다.
본 가이드의 다음 섹션에서 관계에 대해 약간 배우게 된다.</p><p>bash 명령에 사용 된 (<code>:references</code>) 키워드는 모델의 특수 데이터 유형이다.
지정된 모델 이름 끝에 정수 값을 보유할 수 있는 <code>_id</code>를 추가하여 데이터베이스 테이블에 컬럼으로 추가한다. 이해를 돕기 위해 마이그레이션을 실행 한 후 <code>db/schema.rb</code> 파일을 분석해 보기 바란다.</p><p>모델 외에도 레일스는 해당 데이터베이스 테이블을 생성하기 위한 마이그레이션을 작성했다.</p><div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
class CreateComments &lt; ActiveRecord::Migration[6.0]
  def change
    create_table :comments do |t|
      t.string :commenter
      t.text :body
      t.references :article, null: false, foreign_key: true

      t.timestamps
    end
  end
end

</pre>
</div>
<p><code>t.references</code> 줄은 <code>article_id</code>라는 정수 컬럼, 이 컬럼에 대한 인덱스, articles 테이블의 <code>id</code> 컬럼을 가리키는 외래 키 제약 조건을 만든다. 이제 아랭와 같이 마이그레이션을 실행한다.</p><div class="code_container">
<pre class="brush: plain; gutter: false; toolbar: false">
$ rails db:migrate

</pre>
</div>
<p>레일스는 현재 데이터베이스에 대해 아직 실행되지 않은 마이그레이션만 실행하기 때문에 이 경우에는 아래과 같은 결과를 보게 될 것이다.</p><div class="code_container">
<pre class="brush: plain; gutter: false; toolbar: false">
==  CreateComments: migrating =================================================
-- create_table(:comments)
   -&gt; 0.0115s
==  CreateComments: migrated (0.0119s) ========================================

</pre>
</div>
<h4 id="associating-models"><a class="anchorlink" href="#associating-models">6.2 모델 관계 선언하기</a></h4><p>액티브레코드 관계를 사용하면 두 모델 간의 관계를 쉽게 선언 할 수 있다. 댓글과 기사의 경우 다음과 같이 관계를 작성할 수 있다.</p>
<ul>
<li>각 댓글은 하나의 기사에 속한다.</li>
<li>하나의 기사는 다수의 댓글을 가질 수 있다.</li>
</ul>
<p>실제로 이것은 레일스가 이 관계를 선언하는 데 사용하는 문법과 매우 유사하다. <code>Comment</code> 모델 (app/models/comment.rb)에서 각 댓글이 기사에 속하도록 하는 코드 라인을 이미 보았고 아래와 같다.</p><div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
class Comment &lt; ApplicationRecord
  belongs_to :article
end

</pre>
</div>
<p>관계의 다른 쪽을 추가하려면 <code>app/models/article.rb</code>를 수정해야 한다.</p><div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
class Article &lt; ApplicationRecord
  has_many :comments
  validates :title, presence: true,
                    length: { minimum: 5 }
end

</pre>
</div>
<p>이 두 가지 선언을 통해서 몇가지 작업을 자동화할 수 있다. 예를 들어 기사를 포함하는 인스턴스 변수 '@article'가 있는 경우 <code>@ article.comments</code>를 사용하여 해당 기사에 속하는 모든 댓글을 배열로 검색 할 수 있다.</p><div class="info"><p>액티브 레코드 연결에 대한 자세한 내용은 <a href="association_basics.html">Active Record Associations</a> 안내서를 참조한다.</p></div><h4 id="adding-a-route-for-comments"><a class="anchorlink" href="#adding-a-route-for-comments">6.3 댓글에 대한 라우트 추가하기</a></h4><p><code>welcome</code> 컨트롤러와 마찬가지로 <code>comments</code> 리소스에 대한 라우트를 추가해야 할 것이다. <code>config/routes.rb</code> 파일을 다시 열고 아래와 같이 수정한다.</p><div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
resources :articles do
  resources :comments
end

</pre>
</div>
<p>이것은 <code>articles</code> 내에서 <code>comments</code>를 <em>nested resource</em> 상태로 생성한다. 이것은 기사와 댓글 사이에 존재하는 계층적 관계를 적용하는 또 다른 부분이다.</p><div class="info"><p>라우팅에 대한 자세한 내용은 <a href="routing.html">Rails Routing</a> 안내서를 참조한다.</p></div><h4 id="generating-a-controller"><a class="anchorlink" href="#generating-a-controller">6.4 컨트롤러 생성하기</a></h4><p>모델이 준비된 상태에서 다음으로 연관 컨트롤러를 만드는 데 집중해야 한다. 이 때 전에 사용했던 것과 동일한 생성자를 사용할 것이다.</p><div class="code_container">
<pre class="brush: plain; gutter: false; toolbar: false">
$ rails generate controller Comments

</pre>
</div>
<p>이것은 4개의 파일과 하나의 빈 디렉토리를 생성한다.</p>
<table>
<thead>
<tr>
<th>파일/디렉토리</th>
<th>용도</th>
</tr>
</thead>
<tbody>
<tr>
<td>app/controllers/comments_controller.rb</td>
<td>Comments 컨트롤러</td>
</tr>
<tr>
<td>app/views/comments/</td>
<td>해당 컨트롤러에 대한 뷰 파일들이 여기에 저장된다.</td>
</tr>
<tr>
<td>test/controllers/comments_controller_test.rb</td>
<td>해당 컨트롤러에 대한 테스트</td>
</tr>
<tr>
<td>app/helpers/comments_helper.rb</td>
<td>뷰 헬퍼 파일</td>
</tr>
<tr>
<td>app/assets/stylesheets/comments.scss</td>
<td>해당 컨트롤러에 대한 CSS 파일</td>
</tr>
</tbody>
</table>
<p>다른 블로그와 마찬가지로 독자들이 기사를 읽은 직후에 댓글을 작성할 것이며 일단 댓글이 추가되면 기사 보기 페이지로 되돌아가서 해당 기사에 달린 댓글 목록을 보게 될 것이다. 이로 인해 <code>CommentsController</code>는 댓글을 작성하고 스팸 댓글이 달리면 삭제하는 메소드를 제공한다.</p><p>먼저, 기사 보기 템플릿 (<code>app/views/articles/show.html.erb</code>)을 연결하여 새로운 댓글을 작성할 수 있도록 한다.</p><div class="code_container">
<pre class="brush: ruby; html-script: true; gutter: false; toolbar: false">
&lt;p&gt;
  &lt;strong&gt;Title:&lt;/strong&gt;
  &lt;%= @article.title %&gt;
&lt;/p&gt;

&lt;p&gt;
  &lt;strong&gt;Text:&lt;/strong&gt;
  &lt;%= @article.text %&gt;
&lt;/p&gt;

&lt;h2&gt;Add a comment:&lt;/h2&gt;
&lt;%= form_with(model: [ @article, @article.comments.build ], local: true) do |form| %&gt;
  &lt;p&gt;
    &lt;%= form.label :commenter %&gt;&lt;br&gt;
    &lt;%= form.text_field :commenter %&gt;
  &lt;/p&gt;
  &lt;p&gt;
    &lt;%= form.label :body %&gt;&lt;br&gt;
    &lt;%= form.text_area :body %&gt;
  &lt;/p&gt;
  &lt;p&gt;
    &lt;%= form.submit %&gt;
  &lt;/p&gt;
&lt;% end %&gt;

&lt;%= link_to 'Edit', edit_article_path(@article) %&gt; |
&lt;%= link_to 'Back', articles_path %&gt;

</pre>
</div>
<p>이것은 <code>Article</code> 보기 페이지에 <code>CommentsController</code> <code>create</code> 액션을 호출하여 새로운 댓글을 작성하는 폼을 추가한다. 여기서 <code>form_with</code> 메소드 호출할 때 배열을 인수로 사용하는데, <code>/articles/1/comments</code>와 같은 중첩 라우트를 생성해 줄 것이다.</p><p><code>app/controllers/comments_controller.rb</code>에서 <code>create</code> 액션을 아래와 같이 작성하여 연결한다.</p><div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
class CommentsController &lt; ApplicationController
  def create
    @article = Article.find(params[:article_id])
    @comment = @article.comments.create(comment_params)
    redirect_to article_path(@article)
  end

  private
    def comment_params
      params.require(:comment).permit(:commenter, :body)
    end
end

</pre>
</div>
<p>기사 컨트롤러에서 보다 약간 더 복잡해지는 것을 알게 될 것이다. 이것은 중첩 라우팅으로 인한 부작용이다. 댓글에 대한 요청시 마다 댓글이 달린 기사를 기억해 두어야 하므로 <code>Article</code> 모델의 <code>find</code> 메소드를 초기에 호출하여 해당 기사를 확보해 두어야 한다.</p><p>또한 코드 작성시 모델 관계에서 사용할 수 있는 메소드를 활용한다. <code>@article.comments</code>에서 <code>create</code> 메소드를 사용하여 댓글을 작성하고 저장한다. 이렇게 하므로써 댓글이 해당 특정 기사에 속하도록 자동 링크된다.</p><p>새로운 댓글을 작성하면 <code>article_path (@article)</code> 헬퍼를 사용하여 사용자를 원래 기사로 돌려 보낸다. 이미 보았 듯이, 이것은 <code>ArticlesController</code>의<code>show</code> 액션을 호출하여<code>show.html.erb</code> 템플릿을 렌더링한다. 이것은 댓글을 보여줄 위치이므로 <code>app/views/articles/show.html.erb</code>에 댓글을 추가해 보자.</p><div class="code_container">
<pre class="brush: ruby; html-script: true; gutter: false; toolbar: false">
&lt;p&gt;
  &lt;strong&gt;Title:&lt;/strong&gt;
  &lt;%= @article.title %&gt;
&lt;/p&gt;

&lt;p&gt;
  &lt;strong&gt;Text:&lt;/strong&gt;
  &lt;%= @article.text %&gt;
&lt;/p&gt;

&lt;h2&gt;Comments&lt;/h2&gt;
&lt;% @article.comments.each do |comment| %&gt;
  &lt;p&gt;
    &lt;strong&gt;Commenter:&lt;/strong&gt;
    &lt;%= comment.commenter %&gt;
  &lt;/p&gt;

  &lt;p&gt;
    &lt;strong&gt;Comment:&lt;/strong&gt;
    &lt;%= comment.body %&gt;
  &lt;/p&gt;
&lt;% end %&gt;

&lt;h2&gt;Add a comment:&lt;/h2&gt;
&lt;%= form_with(model: [ @article, @article.comments.build ], local: true) do |form| %&gt;
  &lt;p&gt;
    &lt;%= form.label :commenter %&gt;&lt;br&gt;
    &lt;%= form.text_field :commenter %&gt;
  &lt;/p&gt;
  &lt;p&gt;
    &lt;%= form.label :body %&gt;&lt;br&gt;
    &lt;%= form.text_area :body %&gt;
  &lt;/p&gt;
  &lt;p&gt;
    &lt;%= form.submit %&gt;
  &lt;/p&gt;
&lt;% end %&gt;

&lt;%= link_to 'Edit', edit_article_path(@article) %&gt; |
&lt;%= link_to 'Back', articles_path %&gt;

</pre>
</div>
<p>이제 블로그에 기사와 댓글을 추가하고 재위치에 보여 줄 수 있게 되었다.</p><p><img src="images/getting_started/article_with_comments.png" alt="Article with Comments"></p><h3 id="refactoring"><a class="anchorlink" href="#refactoring">7 리팩토링하기</a></h3><p>이제 기사와 댓글이 작성되었으므로 <code>app/views/articles/show.html.erb</code> 템플릿을 살펴 보도록 한다. 코드가 길어지면서 점점 어색해지고 있다. 파셜을 사용하면 깨끗하게 정리할 수 있다.</p><h4 id="rendering-partial-collections"><a class="anchorlink" href="#rendering-partial-collections">7.1 파셜 컬렉션 렌더링하기</a></h4><p>먼저 해당 기사에 대한 모든 댓글을 보여 주기 위해 댓글 파셜을 작성한다. <code>app/views/comments/_comment.html.erb</code> 파일을 생성하고 아래와 같이 입력한다.</p><div class="code_container">
<pre class="brush: ruby; html-script: true; gutter: false; toolbar: false">
&lt;p&gt;
  &lt;strong&gt;Commenter:&lt;/strong&gt;
  &lt;%= comment.commenter %&gt;
&lt;/p&gt;

&lt;p&gt;
  &lt;strong&gt;Comment:&lt;/strong&gt;
  &lt;%= comment.body %&gt;
&lt;/p&gt;

</pre>
</div>
<p>그런 다음 <code>app/views/articles/show.html.erb</code>를 아래와 같이 변경할 수 있다.</p><div class="code_container">
<pre class="brush: ruby; html-script: true; gutter: false; toolbar: false">
&lt;p&gt;
  &lt;strong&gt;Title:&lt;/strong&gt;
  &lt;%= @article.title %&gt;
&lt;/p&gt;

&lt;p&gt;
  &lt;strong&gt;Text:&lt;/strong&gt;
  &lt;%= @article.text %&gt;
&lt;/p&gt;

&lt;h2&gt;Comments&lt;/h2&gt;
&lt;%= render @article.comments %&gt;

&lt;h2&gt;Add a comment:&lt;/h2&gt;
&lt;%= form_with(model: [ @article, @article.comments.build ], local: true) do |form| %&gt;
  &lt;p&gt;
    &lt;%= form.label :commenter %&gt;&lt;br&gt;
    &lt;%= form.text_field :commenter %&gt;
  &lt;/p&gt;
  &lt;p&gt;
    &lt;%= form.label :body %&gt;&lt;br&gt;
    &lt;%= form.text_area :body %&gt;
  &lt;/p&gt;
  &lt;p&gt;
    &lt;%= form.submit %&gt;
  &lt;/p&gt;
&lt;% end %&gt;

&lt;%= link_to 'Edit', edit_article_path(@article) %&gt; |
&lt;%= link_to 'Back', articles_path %&gt;

</pre>
</div>
<p>이것은 이제 <code>@article.comments</code> 컬렉션에 있는 각 댓글마다 <code>app/views/comments/_comment.html.erb</code> 파셜을 한번씩 렌더링한다. <code>render</code> 메소드가 <code>@article.comments</code> 컬렉션을 반복 할 때, 각 댓글을 파셜과 같은 이름의 로컬 변수 (이 경우에는 <code>comment</code>)에 할당하며 이 변수는 파셜 템플릿에서 사용할 수 있다.</p><h4 id="rendering-a-partial-form"><a class="anchorlink" href="#rendering-a-partial-form">7.2 파셜 폼 렌더링하기</a></h4><p>새로운 댓글 섹션을 파셜 템플릿으로 옮기도록 한다. 또 다시, 아래와 같은 내용을 포함하는 <code>app/views/comments/_form.html.erb</code> 파일을 생성한다.</p><div class="code_container">
<pre class="brush: ruby; html-script: true; gutter: false; toolbar: false">
&lt;%= form_with(model: [ @article, @article.comments.build ], local: true) do |form| %&gt;
  &lt;p&gt;
    &lt;%= form.label :commenter %&gt;&lt;br&gt;
    &lt;%= form.text_field :commenter %&gt;
  &lt;/p&gt;
  &lt;p&gt;
    &lt;%= form.label :body %&gt;&lt;br&gt;
    &lt;%= form.text_area :body %&gt;
  &lt;/p&gt;
  &lt;p&gt;
    &lt;%= form.submit %&gt;
  &lt;/p&gt;
&lt;% end %&gt;

</pre>
</div>
<p>그런 다음 <code>app/views/articles/show.html.erb</code>를 아래와 같이 작성한다.</p><div class="code_container">
<pre class="brush: ruby; html-script: true; gutter: false; toolbar: false">
&lt;p&gt;
  &lt;strong&gt;Title:&lt;/strong&gt;
  &lt;%= @article.title %&gt;
&lt;/p&gt;

&lt;p&gt;
  &lt;strong&gt;Text:&lt;/strong&gt;
  &lt;%= @article.text %&gt;
&lt;/p&gt;

&lt;h2&gt;Comments&lt;/h2&gt;
&lt;%= render @article.comments %&gt;

&lt;h2&gt;Add a comment:&lt;/h2&gt;
&lt;%= render 'comments/form' %&gt;

&lt;%= link_to 'Edit', edit_article_path(@article) %&gt; |
&lt;%= link_to 'Back', articles_path %&gt;

</pre>
</div>
<p>두 번째 render 메소드는 파셜 템플릿 <code>comments/form</code>을 정의한다. 레일스는 이 문자열에서 슬래시를 인식할 수 있기 때문에 <code>_form.html.erb</code> 파일을 <code>app/views/comments</code> 디렉토리에 렌더링하게 된다.</p><p><code>@article</code> 객체는 인스턴스 변수로 정의 되었기 때문에 뷰에서 렌더링되는 모든 파셜에서 사용할 수 있다.</p><h3 id="deleting-comments"><a class="anchorlink" href="#deleting-comments">8 댓글 삭제하기</a></h3><p>블로그의 또 다른 중요한 기능은 스팸 댓글을 삭제할 수 있어야 한다. 이를 위해서 뷰에서 댓글 삭제를 위한 링크와 <code>CommentsController</code>에서 <code>destroy</code> 액션을 구현해야 한다.</p><p>먼저 <code>app/views/comments/_comment.html.erb</code> 파셜에 삭제 링크를 추가한다.</p><div class="code_container">
<pre class="brush: ruby; html-script: true; gutter: false; toolbar: false">
&lt;p&gt;
  &lt;strong&gt;Commenter:&lt;/strong&gt;
  &lt;%= comment.commenter %&gt;
&lt;/p&gt;

&lt;p&gt;
  &lt;strong&gt;Comment:&lt;/strong&gt;
  &lt;%= comment.body %&gt;
&lt;/p&gt;

&lt;p&gt;
  &lt;%= link_to 'Destroy Comment', [comment.article, comment],
               method: :delete,
               data: { confirm: 'Are you sure?' } %&gt;
&lt;/p&gt;

</pre>
</div>
<p>새로이 추가한 "Destroy Comment" 링크를 클릭하면 <code>CommentsController</code>로 <code>DELETE /articles/:article_id/comments/:id</code>를 라우팅하게 되며, 이로써 삭제하려는 댓글을 찾을 수 있게 된다. 이어서 컨트롤러(<code>app/controllers/comments_controller.rb</code>)에 <code>destroy</code> 액션을 추가한다.</p><div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
class CommentsController &lt; ApplicationController
  def create
    @article = Article.find(params[:article_id])
    @comment = @article.comments.create(comment_params)
    redirect_to article_path(@article)
  end

  def destroy
    @article = Article.find(params[:article_id])
    @comment = @article.comments.find(params[:id])
    @comment.destroy
    redirect_to article_path(@article)
  end

  private
    def comment_params
      params.require(:comment).permit(:commenter, :body)
    end
end

</pre>
</div>
<p><code>destroy</code> 액션는 우선 기사를 먼저 찾은 후 <code>@article.comments</code> 컬렉션에서 대상 댓글을 찾아 데이터베이스에서 제거하고 기사의 show 액션으로 돌려 보낸다.</p><h4 id="deleting-associated-objects"><a class="anchorlink" href="#deleting-associated-objects">8.1 관련 객체 삭제하기</a></h4><p>기사를 삭제하면 관련 댓글도 삭제해야 한다. 그렇지 않으면 사용하지 않는 댓글이 데이터베이스의 공간을 차지하게 된다. 레일스를 사용하면 관계 설정시 <code>dependent</code> 옵션을 사용하여 이런 문제를 해결할 수 있다. 아래와 같이 Article 모델 <code>app/models/article.rb</code>를 수정한다.</p><div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
class Article &lt; ApplicationRecord
  has_many :comments, dependent: :destroy
  validates :title, presence: true,
                    length: { minimum: 5 }
end

</pre>
</div>
<h3 id="security"><a class="anchorlink" href="#security">9 보안</a></h3><h4 id="basic-authentication"><a class="anchorlink" href="#basic-authentication">9.1 기본 인증</a></h4><p>블로그를 온라인으로 게시할 경우, 누구나 기사를 추가, 수정, 삭제할 수 있으며 댓글을 삭제할 수 있다.</p><p>레일스는 이런 상황에서 잘 작동하는 매우 간단한 HTTP 인증 시스템을 제공한다.</p><p><code>ArticlesController</code>에서는 인증되지 않은 사용자의 경우 액션에 대한 접근 권한을 차단하는 방법이 필요하다. 여기서 레일스 <code>http_basic_authenticate_with</code> 메소드를 사용할 수 있는데, 이 메소드가 허용하는 경우 요청된 액션에 대해 접근할 수 있게 한다.</p><p>인증 시스템을 사용하기 위해 <code>app/controllers/articles_controller.rb</code> 파일에 있는 <code>ArticlesController</code> 상단에 이것을 명시한다. 여기서는 <code>index</code>와 <code>show</code>를 제외한 모든 액션에 대해 사용자가 인증되기를 원한다.</p><div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
class ArticlesController &lt; ApplicationController

  http_basic_authenticate_with name: "dhh", password: "secret", except: [:index, :show]

  def index
    @articles = Article.all
  end

  # snippet for brevity

</pre>
</div>
<p>또한 인증된 사용자만이 댓글을 삭제할 수 있도록 하기 위해 <code>CommentsController</code> (<code>app/controllers/comments_controller.rb</code>)에서 아래와 같이 작성한다.</p><div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
class CommentsController &lt; ApplicationController

  http_basic_authenticate_with name: "dhh", password: "secret", only: :destroy

  def create
    @article = Article.find(params[:article_id])
    # ...
  end

  # snippet for brevity

</pre>
</div>
<p>이제 새 기사를 작성하려고 하면 기본 HTTP 인증창이 표시된다.</p><p><img src="images/getting_started/challenge.png" alt="Basic HTTP Authentication Challenge"></p><p>레일스 애플리케이션에 다른 인증 방법을 사용할 수 있다. 레일스에 널리 사용되는 두 가지 인증 애드온은 <a href="https://github.com/plataformatec/devise">Devise</a> 레일스 엔진과 <a href="https://github.com/binarylogic/authlogic">Authlogic</a> 젬이 있으며 기타 다른 젬들도 다수 존재한다.</p><h4 id="other-security-considerations"><a class="anchorlink" href="#other-security-considerations">9.2 다른 보안 고려사항</a></h4><p>특히 웹 애플리케이션의 보안은 광범위하고 세밀한 분야이다. 레일스 애플리케이션의 보안은 <a href="security.html">Ruby on Rails Security Guide</a>에 자세히 설명되어 있다.</p><h3 id="whats-next"><a class="anchorlink" href="#whats-next">10 향후 계획</a></h3><p>이제 처음으로 레일스 애플리케이션을 경험해 보았으므로 자유롭게 수정해 보고  마음 껏 테스트해 보기 바란다.</p><p>도움없이 모든 것을 할 필요는 없다는 것을 기억하기 바란다. 레일스를 작동시키는데 도움이 필요할 경우 아래의 지원 리소스를 참조하면 된다.</p>
<ul>
<li><a href="index.html">Ruby on Rails Guides</a></li>
<li><a href="https://www.railstutorial.org/book">Ruby on Rails Tutorial</a></li>
<li><a href="https://groups.google.com/group/rubyonrails-talk">Ruby on Rails mailing list</a></li>
<li>irc.freenode.net : <a href="irc://irc.freenode.net/#rubyonrails">#rubyonrails</a> 채널</li>
</ul>
<h3 id="configuration-gotchas"><a class="anchorlink" href="#configuration-gotchas">11 설정시 유의사항</a></h3><p>레일스를 사용하는 가장 쉬운 방법은 모든 외부 데이터를 UTF-8로 저장하는 것이다. 그렇지 못할 경우, 루비 라이브러리와 레일스가 종종 원본 데이터를 UTF-8로 변환 할 수 있지만 항상 안정적으로 작동하는 것이 아니므로 모든 외부 데이터가 UTF-8인지 확인하는 것이 좋다.</p><p>이 부분에서 실수를 할 때 발생하는 가장 일반적인 증상은 브라우저에 가운데 물음표가 있는 검은 색 다이아몬드가 표시된다는 것이다. 또 다른 일반적인 증상은 "ü" 문자가 "Ã"와 같은 문자로 보이는 것이다. 레일스는 이러한 문제의 일반적인 원인을 완화하기 위해 자동으로 감지하고 수정할 수 있는  여러 가지 내부 단계를 수행한다. 그러나 UTF-8로 저장되지 않은 외부 데이터가 있는 경우 레일스에서 자동으로 감지하여 수정할 수 없는 이러 종류의 문제가 발생할 수 있다.</p><p>UTF-8이 아닌 두 가지 매우 일반적인 데이터 소스:</p>
<ul>
<li>사용 중인 텍스트 에디터: (TextMate와 같은) 대부분의 텍스트 에디터들은 기본적으로 UTF-8 인코딩 방식으로 파일을 저장한다. 그렇지 못할 경우, (é와 같은) 특수한 문자를 템플릿 파일에 입력할 경우 브라우저 상에서 가운데 물음표가 있는 다이어몬드 문자로 표시될 수 있다. 또한 이러한 무제는 i18n 변환 파일에도 적용된다. Dreamweaver의 일부 버전에서와 같이 UTF-8을 기본 인코딩 방식으로 지정하지 않는 대부분의 에디터들은 기본 인코딩을 UTF-8로 변경할 수 있는 방법을 제공한다. 이와 같이 설정을 변경해 두도록 한다.</li>
<li>사용 중인 데이터베이스: 레일스는 기본적으로 데이터베이스로부터 가져 오는 데이터를 UTF-8 인코딩 방식으로 변환한다. 그러나 사용 중인 데이터베이스가 내부적으로 UTF-8을 사용하지 않을 경우, 사용자가 입력하는 모든 문자들을 저장하지 못할 수 있다. 예를 들어, 사용 중인 데이터베이스가 내부적으로 Latin-1 인코딩을 사용하고 있는 상태에서 사용자들이 러시아어, 히브리어, 일본어를 입력할 경우 데이터는 일단 데이터베이스로 들어 간후 영구히 소실될 것이다. 가능한한 데이터베이스의 내부 저장 방식을 UTF-8로 지정하도록 한다.</li>
</ul>


        <h3>피드백</h3>
        <p>
          이 가이드의 품질을 향상시키기 위해 여러분의 도움이 필요하다.
        </p>
        <p>
          오타나 실제 오류를 발견시 여러분의 기여를 권고한다. 시작하려면 본 <a href="https://edgeguides.rubyonrails.org/contributing_to_ruby_on_rails.html#contributing-to-the-rails-documentation">가이드의 기여</a> 섹션을 읽어보기 바란다.
        </p>
        <p>
          미완성된 컨텐츠나 업데이트되지 않은 내용을 발견할 수도 있다. 누락된 문서는 master 브랜치에 추가한다. 제시된 이슈들이 master 브랜치 상에서 이미 해결되었는지 여부를 확인하려면 먼저 <a href="https://edgeguides.rubyonrails.org">Edge Guides</a>를 확인한다. 스타일과 규칙에 대해서는 <a href="ruby_on_rails_guides_guidelines.html">Ruby on Rails Guides Guidelines</a>을 확인한다.
        </p>
        <p>
          어떤 이유로든 고칠 수 있지만 직접 패치 할 수 없는 경우 <a href="https://github.com/rails/rails/issues">이슈를 새로 오픈</a>하면 된다. 
        </p>
        <p>
          그리고 마지막으로, 루비온레일스 문서에 관한 모든 논의는 <a href="https://groups.google.com/forum/#!forum/rubyonrails-docs">rubyonrails-docs 메일링 리스트</a> 상에서 언제든지 가능하다. 
        </p>
      </div>
    </div>
  </div>

  <hr class="hide" />
  <div id="footer">
    <div class="wrapper">
      <p>본 결과물은 <a href="https://creativecommons.org/licenses/by-sa/4.0/">Creative Commons Attribution-ShareAlike 4.0 International License</a> 를 준수한다. </p>
<p>"Rails", "Ruby on Rails", 그리고 레일스 로고는 David Heinemeier Hansson의 등록상표이다. 판권 소유.</p>

    </div>
  </div>
</body>
</html>
